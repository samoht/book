<html class="js flexbox fontface" lang="en" style=""><head><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Real World OCaml</title><link rel="stylesheet" href="css/app.css"/><link rel="stylesheet" href="css/prism.css"/><script src="js/min/modernizr-min.js"></script><script src="js/prism.js"></script><script src="//use.typekit.net/gfj8wez.js"></script><script>try{Typekit.load();}catch(e){}</script></head></head><body><div class="title-bar"><div class="title"><h1>Real World OCaml</h1><h5>2<sup>nd</sup> Edition (in progress)</h5><nav><a href="index.html">Home</a><a href="toc.html">Table of Contents</a><a href="faqs.html">FAQs</a><a href="install.html">Install</a><a href="https://ocaml.janestreet.com/ocaml-core/">API Docs</a></nav></div></div><div class="wrap"><div class="left-column"><a href="toc.html" class="to-chapter"><small>Back</small><h5>Table of Contents</h5></a></div><article class="main-body">
    <section xmlns="http://www.w3.org/1999/xhtml" id="command-line-parsing" data-type="chapter">
      <h1>Command-Line Parsing</h1>

      <p>
	Many of the OCaml programs that you'll write will end up as
	binaries that need to be run from a command prompt. Any
	nontrivial command line should support a collection of basic
	features:</p>

      <ul><li><p>
	    Parsing of command-line arguments</p></li>

	<li> <p>
	    Generation of error messages in response to incorrect
            inputs</p></li>

	<li> <p>
	    Help for all the available options </p> </li>

	<li> <p>
	    Interactive autocompletion</p> </li>
      </ul>

      <p>
	It's tedious and error-prone to code all of this manually
	for every program you write. Core provides the Command library,
	which simplifies all of this by letting you declare all your
	command-line options in one place and by deriving all of the
	above functionality from these declarations.

	<a data-type="indexterm" data-primary="command-line parsing" data-secondary="Command library for">&nbsp;</a></p>

      <p>
	Command is simple to use for simple applications but also
	scales well as your needs grow more complex. In particular,
	Command provides a sophisticated subcommand mode that groups
	related commands together as the complexity of your user
	interface grows. You may already be familiar with this
	command-line style from the Git or Mercurial version control
	systems.</p>

      <p>
	In this chapter, we'll:</p>

      <ul>
	<li>
          <p>
	    Learn how to use Command to construct basic and grouped
            command-line interfaces</p>
	</li>

	<li>
          <p>
	    We will build simple equivalents to the cryptographic
            <code>md5</code> and <code>shasum</code> utilities</p>
	</li>

	<li>
          <p>
	    Demonstrate how <em>functional combinators</em> can be
            used to declare complex command-line interfaces in a
            type-safe and elegant way

	    <a data-type="indexterm" data-primary="combinators" data-secondary="functional combinators">&nbsp;</a></p>
	</li>
      </ul>

      <section id="basic-command-line-parsing" data-type="sect1">
	<h1>Basic Command-Line Parsing</h1>

	<p>
	  Let's start by working through a clone of the
	  <em>md5sum</em> command that is present on most Linux
	  installations (the equivalent command on Mac OS X is simply
	  <code>md5</code>). The following function defined below reads
	  in the contents of a file, applies the MD5 one-way
	  cryptographic hash function to the data, and outputs an ASCII
	  hex representation of the result:

	  <a data-type="indexterm" data-primary="MD5 one-way cryptographic hash function">&nbsp;</a>
	  <a data-type="indexterm" data-primary="command-line parsing" data-secondary="basic approach to">&nbsp;</a></p>

	<div class="highlight"><pre><code class="language-ocaml">open Core

let do_hash file =
  In_channel.with_file file ~f:(fun ic -&gt;
    let open Cryptokit in
    hash_channel (Hash.md5 ()) ic
    |&gt; transform_string (Hexa.encode ())
    |&gt; print_endline
  )</code></pre></div>

	<p>
	  The <code>do_hash</code> function accepts a
	  <code>filename</code> parameter and prints the human-readable
	  MD5 string to the console standard output. The first step
	  toward turning this function into a command-line program is
	  to declare all the possible command-line arguments in a
	  <em>specification</em>. <code>Command.Spec</code> defines
	  combinators that can be chained together to define optional
	  flags and positional arguments, what types they should map
	  to, and whether to take special actions (such as pausing for
	  interactive input) if certain inputs are encountered.</p>

	<section id="anonymous-arguments" data-type="sect2">
          <h2>Anonymous Arguments</h2>

          <p>
	    Let's build the specification for a single argument that
            is passed directly on the command line. This is known as
            an <em>anonymous</em> argument:

	    <a data-type="indexterm" data-primary="arguments" data-secondary="anonymous arguments">&nbsp;</a>
	    <a data-type="indexterm" data-primary="anonymous arguments">&nbsp;</a></p>

          <div class="highlight"><pre><code class="language-ocaml">let spec =
  let open Command.Spec in
  empty
  +&gt; anon ("filename" %: string)</code></pre></div>

          <p>
	    The <code>Command.Spec</code> module defines the tools
            you'll need to build up a command-line specification. We
            start with the <code>empty</code> value and add parameters
            to that using the <code>+&gt;</code> combinator. (Both of
            these values come from <code>Command.Spec</code>.)</p>

          <p>
	    In this case, we defined a single anonymous argument
            called <code>filename</code>, which takes a value of type
            <code>string</code>. Anonymous parameters are created using
            the <code>%:</code> operator, which binds a textual name
            (used in the help text to identify the parameter) to an
            OCaml conversion function that parses the command-line
            string fragments into a higher-level OCaml data type. In
            the preceding example, this is just
            <code>Command.Spec.string</code>, but we'll see more
            complex conversion options later in the chapter.</p>
	</section>

	<section id="defining-basic-commands" data-type="sect2">
          <h2>Defining Basic Commands</h2>

          <p>
	    Once we've defined a specification, we need to put it to
            work on real input. The simplest way is to directly create
            a command-line interface via the <code>Command.basic</code>
            module:

	    <a data-type="indexterm" data-primary="Command.basic module">&nbsp;</a></p>

          <div class="highlight"><pre><code class="language-ocaml">let command =
  Command.basic_spec
    ~summary:"Generate an MD5 hash of the input data"
    ~readme:(fun () -&gt; "More detailed information")
    spec
    (fun filename () -&gt; do_hash filename)</code></pre></div>

          <p>
	    <code>Command.basic</code> defines a complete
            command-line interface that takes the following extra
            arguments, in addition to the ones defined in the
            specification:</p>

          <dl>
            <dt><code>summary</code></dt>

            <dd>
              <p>
		A required one-line description to go at the top of
		the command help screen.</p>
            </dd>

            <dt><code>readme</code></dt>

            <dd>
              <p>
		For longer help text when the command is called with
		<code>-help</code>. The <code>readme</code> argument is
		a function that is only evaluated when the help text is
		actually needed.</p>
            </dd>
          </dl>

          <p>
	    The specification and the callback function follow as
            nonlabeled arguments.</p>

          <p>
	    The callback function is where all the work happens
            after the command-line parsing is complete. This function
            is applied with the arguments containing the parsed
            command-line values, and it takes over as the main thread
            of the application. The callback's arguments are passed in
            the same order as they were bound in the specification
            (using the <code>+&gt;</code> operator).

	    <a data-type="indexterm" data-primary="arguments" data-secondary="unit argument to callbacks">&nbsp;</a>
	    <a data-type="indexterm" data-primary="unit argument">&nbsp;</a>
	    <a data-type="indexterm" data-primary="callback function">&nbsp;</a></p>

          <div data-type="note">
            <h1>The Extra unit Argument to Callbacks</h1>

            <p>
	      The preceding callback needs an extra
              <code>unit</code> argument after <code>filename</code>.
              This is to ensure that specifications can work even when
              they are empty (i.e. the <code>Command.Spec.empty</code>
              value).</p>

            <p>
	      Every OCaml function needs at least one argument, so
              the final <code>unit</code> guarantees that it will not
              be evaluated immediately as a value if there are no other
              arguments.</p>
          </div>
	</section>

	<section id="running-basic-commands" data-type="sect2">
          <h2>Running Basic Commands</h2>

          <p>
	    Once we've defined the basic command, running it is just
            one function call away:</p>

          <div class="highlight"><pre><code class="language-ocaml">let () =
  Command.run ~version:"1.0" ~build_info:"RWO" command</code></pre></div>

          <p>
	    <code>Command.run</code> takes a couple of optional
            arguments that are useful to identify which version of the
            binary you are running in production. You'll need to
            install Cryptokit via <code>opam install cryptokit</code>
            before building this example. Once that's completed, run
            the following to compile the binary:</p>
          <div class="highlight"><pre><code class="language-ocaml">(executable ((name basic_md5) (libraries (core cryptokit))))
</code></pre></div>
          <div class="highlight"><pre><code class="language-ocaml">$ jbuilder build basic_md5.exe
    ocamldep basic_md5.depends.ocamldep-output
      ocamlc basic_md5.{cmi,cmo,cmt}
    ocamlopt basic_md5.{cmx,o}
    ocamlopt basic_md5.exe
ld: warning: directory not found for option '-L/opt/local/lib'
</code></pre></div>

          <p>
	    You can now query the version information for the binary
            you just compiled:</p>

          <div class="highlight"><pre><code class="language-ocaml">$ ./_build/default/basic_md5.exe -version
1.0
$ ./_build/default/basic_md5.exe -build-info
RWO
</code></pre></div>

          <p>
	    The versions that you see in the output were defined via
            the optional arguments to <code>Command.run</code>. You can
            leave these blank in your own programs or get your build
            system to generate them directly from your version control
            system (e.g., by running <code>hg id</code> to generate a
            build revision number, in the case of Mercurial):</p>

          <div class="highlight"><pre><code class="language-ocaml">$ ./_build/default/basic_md5.exe
Error parsing command line.  Run with -help for usage information.
missing anonymous argument: FILENAME
</code></pre></div>

          <p>
	    When we invoke this binary without any arguments, it
            helpfully displays all of the command-line options
            available, along with a message to the standard error that
            informs you that a required argument <code>filename</code>
            is missing.</p>

          <p>
	    If you do supply the <code>filename</code> argument,
            then <code>do_hash</code> is called with the argument and
            the MD5 output is displayed to the standard output:</p>

          <div class="highlight"><pre><code class="language-ocaml">$ ./_build/default/basic_md5.exe ./_build/default/basic_md5.exe
fc69a5fbc0a72068926ef15e3cab30d9
</code></pre></div>

          <p>
	    And that's all it took to build our little MD5 utility!
            Here's a complete version of the example we just walked
            through, made slightly more succinct by removing
            intermediate variables:</p>

          <div class="highlight"><pre><code class="language-ocaml">open Core

let do_hash file () =
  In_channel.with_file file ~f:(fun ic -&gt;
    let open Cryptokit in
    hash_channel (Hash.md5 ()) ic
    |&gt; transform_string (Hexa.encode ())
    |&gt; print_endline
  )

let command =
  Command.basic
    ~summary:"Generate an MD5 hash of the input data"
    ~readme:(fun () -&gt; "More detailed information")
    Command.Spec.(empty +&gt; anon ("filename" %: string))
    do_hash

let () =
  Command.run ~version:"1.0" ~build_info:"RWO" command</code></pre></div>

          <p>
	    Now that we have the basics in place, the rest of the
            chapter will examine some of the more advanced features of
            Command.</p>
	</section>
      </section>

      <section id="argument-types" data-type="sect1">
	<h1>Argument Types</h1>

	<p>
	  You aren't just limited to parsing command lines as
	  strings, of course. <code>Command.Spec</code> defines several
	  other conversion functions (shown in <a href="14-command-line-parsing.html#table14_1" data-type="xref">Table14_1</a>) that validate and parse input into
	  various types.

	  <a data-type="indexterm" data-primary="arguments" data-secondary="argument types">&nbsp;</a>
	  <a data-type="indexterm" data-primary="command-line parsing" data-secondary="argument types">&nbsp;</a></p>

	<table id="table14_1">
          <caption>
            Conversion functions defined by <code>Command.spec</code>
          </caption>

          <thead>
            <tr>
              <th>Argument type</th>

              <th>OCaml type</th>

              <th>Example</th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td><code>string</code></td>

              <td><code>string</code></td>

              <td><code>foo</code></td>
            </tr>

            <tr>
              <td><code>int</code></td>

              <td><code>int</code></td>

              <td><code>123</code></td>
            </tr>

            <tr>
              <td><code>float</code></td>

              <td><code>float</code></td>

              <td><code>123.01</code></td>
            </tr>

            <tr>
              <td><code>bool</code></td>

              <td><code>bool</code></td>

              <td><code>true</code></td>
            </tr>

            <tr>
              <td><code>date</code></td>

              <td><code>Date.t</code></td>

              <td><code>2013-12-25</code></td>
            </tr>

            <tr>
              <td><code>time_span</code></td>

              <td><code>Span.t</code></td>

              <td><code>5s</code></td>
            </tr>

            <tr>
              <td><code>file</code></td>

              <td><code>string</code></td>

              <td><code>/etc/passwd</code></td>
            </tr>
          </tbody>
	</table>

	<p>
	  We can tighten up the specification of the command to
	  <code>file</code> to reflect that the argument must be a
	  valid filename, and not just any string:</p>

	<div class="highlight"><pre><code class="language-ocaml">let command =
  Command.basic_spec
    ~summary:"Generate an MD5 hash of the input data"
    ~readme:(fun () -&gt; "More detailed information")
    Command.Spec.(empty +&gt; anon ("filename" %: file))
    do_hash

let () =
  Command.run ~version:"1.0" ~build_info:"RWO" command</code></pre></div>

	<p>
	  Running this with a nonexistent filename will now output
	  an error if the file doesn't exist. As a bonus, it also
	  enables interactive command-line completion to work on the
	  filename argument (explained later in the chapter):</p>

	<div class="highlight"><pre><code class="language-ocaml">$ jbuilder build basic_md5_as_filename.exe
    ocamldep basic_md5_as_filename.depends.ocamldep-output
      ocamlc basic_md5_as_filename.{cmi,cmo,cmt}
    ocamlopt basic_md5_as_filename.{cmx,o}
    ocamlopt basic_md5_as_filename.exe
ld: warning: directory not found for option '-L/opt/local/lib'
$ ./_build/default/basic_md5_as_filename.exe nonexistent
Uncaught exception:
  
  (Sys_error "nonexistent: No such file or directory")

Raised by primitive operation at file "pervasives.ml", line 389, characters 28-54
Called from file "src/in_channel.ml", line 20, characters 45-66
Called from file "src/command.ml", line 2734, characters 6-97
Called from file "src/exn.ml", line 108, characters 6-10
</code></pre></div>

	<section id="defining-custom-argument-types" data-type="sect2">
          <h2>Defining Custom Argument Types</h2>

          <p>
	    We can also define our own argument types if the
            predefined ones aren't sufficient. For instance, let's make
            a <code>regular_file</code> argument type that ensures that
            the input file isn't a character device or some other odd
            UNIX file type that can't be fully read:

	    <a data-type="indexterm" data-primary="arguments" data-secondary="defining custom types">&nbsp;</a></p>

          <div class="highlight"><pre><code class="language-ocaml">open Core

let do_hash file () =
  In_channel.with_file file ~f:(fun ic -&gt;
    let open Cryptokit in
    hash_channel (Hash.md5 ()) ic
    |&gt; transform_string (Hexa.encode ())
    |&gt; print_endline
  )

let regular_file =
  Command.Spec.Arg_type.create
    (fun filename -&gt;
       match Sys.is_file filename with
       | `Yes -&gt; filename
       | `No | `Unknown -&gt;
         eprintf "'%s' is not a regular file.\n%!" filename;
         exit 1
    )

let command =
  Command.basic_spec
    ~summary:"Generate an MD5 hash of the input data"
    ~readme:(fun () -&gt; "More detailed information")
    Command.Spec.(empty +&gt; anon ("filename" %: regular_file))
    do_hash

let () =
  Command.run ~version:"1.0" ~build_info:"RWO" command</code></pre></div>

          <p>
	    The <code>regular_file</code> function transforms a
            <code>filename</code> string parameter into the same string
            but first checks that the file exists and is a regular file
            type. When you build and run this code, you will see the
            new error messages if you try to open a special device such
            as <code>/dev/null</code>:</p>

          <div class="highlight"><pre><code class="language-ocaml">$ jbuilder build basic_md5_with_custom_arg.exe
    ocamldep basic_md5_with_custom_arg.depends.ocamldep-output
      ocamlc basic_md5_with_custom_arg.{cmi,cmo,cmt}
    ocamlopt basic_md5_with_custom_arg.{cmx,o}
    ocamlopt basic_md5_with_custom_arg.exe
ld: warning: directory not found for option '-L/opt/local/lib'
$ ./_build/default/basic_md5_with_custom_arg.exe /etc/passwd
b88d621596b7e61337e832f7841066a9
$ ./_build/default/basic_md5_with_custom_arg.exe /dev/null
'/dev/null' is not a regular file.
</code></pre></div>
        </section>

	<section id="optional-and-default-arguments" data-type="sect2">
          <h2>Optional and Default Arguments</h2>

          <p>
	    A more realistic MD5 binary could also read from the
            standard input if a <code>filename</code> isn't
            specified:

	    <a data-type="indexterm" data-primary="arguments" data-secondary="default arguments">&nbsp;</a>
	    <a data-type="indexterm" data-primary="default arguments">&nbsp;</a>
	    <a data-type="indexterm" data-primary="optional arguments" data-secondary="and default arguments">&nbsp;</a>
	    <a data-type="indexterm" data-primary="arguments" data-secondary="optional arguments">&nbsp;</a></p>

          <div class="highlight"><pre><code class="language-ocaml">let command =
  Command.basic_spec
    ~summary:"Generate an MD5 hash of the input data"
    ~readme:(fun () -&gt; "More detailed information")
    Command.Spec.(empty +&gt; anon (maybe ("filename" %: string)))
    do_hash

let () =
  Command.run ~version:"1.0" ~build_info:"RWO" command</code></pre></div>

          <p>
	    This just wraps the <code>filename</code> argument
            declaration in the <code>maybe</code> function to mark it
            as an optional argument. However, building this results in
            a compile-time error:</p>
          <div class="highlight"><pre><code class="language-ocaml">(executable (
  (name basic_md5_with_optional_file_broken) (libraries (core cryptokit))))
</code></pre></div>
          <div class="highlight"><pre><code class="language-ocaml">$ jbuilder build basic_md5_with_optional_file_broken.exe
Error: exception Sys_error("jbuild.inc: No such file or directory")
Backtrace:
Raised by primitive operation at file "pervasives.ml", line 389, characters 28-54
Called from file "src/io.ml", line 15, characters 11-31
Called from file "src/jbuild.ml", line 979, characters 22-71
Called from file "src/sexp.ml", line 339, characters 36-48
Called from file "list.ml", line 82, characters 20-23
Called from file "src/import.ml" (inlined), line 68, characters 31-41
Called from file "src/jbuild.ml", line 1005, characters 4-71
Called from file "src/jbuild.ml", line 1009, characters 6-63
Called from file "src/jbuild_load.ml", line 164, characters 33-64
Called from file "src/jbuild_load.ml", line 224, characters 23-44
Called from file "src/jbuild_load.ml", line 234, characters 16-58
Called from file "src/main.ml", line 26, characters 13-56
Called from file "bin/main.ml", line 547, characters 7-29
Called from file "vendor/cmdliner/src/cmdliner_term.ml", line 27, characters 19-24
Called from file "vendor/cmdliner/src/cmdliner.ml", line 106, characters 32-39
Called from file "vendor/cmdliner/src/cmdliner.ml", line 136, characters 18-36
Called from file "vendor/cmdliner/src/cmdliner.ml", line 251, characters 22-48
Called from file "bin/main.ml", line 1176, characters 10-51
</code></pre></div>

          <p>
	    This is because changing the argument type has also
            changed the type of the callback function. It now wants a
            <code>string option</code> instead of a
            <code>string</code>, since the value has become optional.
            We can adapt our example to use the new information and
            read from standard input if no file is specified:</p>

          <div class="highlight"><pre><code class="language-ocaml">open Core

let get_inchan = function
  | None | Some "-" -&gt;
    In_channel.stdin
  | Some filename -&gt;
    In_channel.create ~binary:true filename

let do_hash filename () =
  let open Cryptokit in
  get_inchan filename
  |&gt; hash_channel (Hash.md5 ())
  |&gt; transform_string (Hexa.encode ())
  |&gt; print_endline

let command =
  Command.basic_spec
    ~summary:"Generate an MD5 hash of the input data"
    ~readme:(fun () -&gt; "More detailed information")
    Command.Spec.(empty +&gt; anon (maybe ("filename" %: file)))
    do_hash

let () =
  Command.run ~version:"1.0" ~build_info:"RWO" command</code></pre></div>

          <p>
	    The <code>filename</code> parameter to
            <code>do_hash</code> is now a <code>string option</code>
            type. This is resolved into an input channel via
            <code>get_inchan</code> to determine whether to open the
            standard input or a file, and then the rest of the command
            is similar to our previous examples.</p>

          <p>
	    Another possible way to handle this would be to supply a
            dash as the default filename if one isn't specified. The
            <code>maybe_with_default</code> function can do just this,
            with the benefit of not having to change the callback
            parameter type (which may be a problem in more complex
            applications).</p>

          <p>
	    The following example behaves exactly the same as the
            previous example, but replaces <code>maybe</code> with
            <code>maybe_with_default</code>:</p>

          <div class="highlight"><pre><code class="language-ocaml">open Core

let get_inchan = function
  | "-"      -&gt; In_channel.stdin
  | filename -&gt; In_channel.create ~binary:true filename

let do_hash filename () =
  let open Cryptokit in
  get_inchan filename
  |&gt; hash_channel (Hash.md5 ())
  |&gt; transform_string (Hexa.encode ())
  |&gt; print_endline

let command =
  Command.basic_spec
    ~summary:"Generate an MD5 hash of the input data"
    ~readme:(fun () -&gt; "More detailed information")
    Command.Spec.(
      empty
      +&gt; anon (maybe_with_default "-" ("filename" %: file))
    ) 
    do_hash

let () =
  Command.run ~version:"1.0" ~build_info:"RWO" command</code></pre></div>

          <p>
	    Building and running both against a system file confirms
            that they have the same behavior:</p>

          <div class="highlight"><pre><code class="language-ocaml">(executables (
  (names (basic_md5_with_optional_file basic_md5_with_default_file))
  (libraries (core cryptokit))))
</code></pre></div>
          <div class="highlight"><pre><code class="language-ocaml">$ jbuilder build basic_md5_with_optional_file.exe
    ocamldep basic_md5_with_optional_file.depends.ocamldep-output
      ocamlc basic_md5_with_optional_file.{cmi,cmo,cmt}
    ocamlopt basic_md5_with_optional_file.{cmx,o}
    ocamlopt basic_md5_with_optional_file.exe
ld: warning: directory not found for option '-L/opt/local/lib'
$ jbuilder build basic_md5_with_default_file.exe
      ocamlc basic_md5_with_default_file.{cmi,cmo,cmt}
    ocamlopt basic_md5_with_default_file.{cmx,o}
    ocamlopt basic_md5_with_default_file.exe
ld: warning: directory not found for option '-L/opt/local/lib'
</code></pre></div>
          <div class="highlight"><pre><code class="language-ocaml">$ cat /etc/passwd | ./_build/default/basic_md5_with_optional_file.exe
b88d621596b7e61337e832f7841066a9
$ cat /etc/passwd | ./_build/default/basic_md5_with_default_file.exe
b88d621596b7e61337e832f7841066a9
</code></pre></div>
        </section>

	<section id="sequences-of-arguments" data-type="sect2">
          <h2>Sequences of Arguments</h2>

          <p>
	    One last transformation that's useful is to obtain lists
            of anonymous arguments rather than a single one. As an
            example, let's modify our MD5 code to take a collection of
            files to process on the command line:

	    <a data-type="indexterm" data-primary="arguments" data-secondary="sequences of">&nbsp;</a></p>

          <div class="highlight"><pre><code class="language-ocaml">open Core

let do_hash filename ic =
  let open Cryptokit in
  hash_channel (Hash.md5 ()) ic
  |&gt; transform_string (Hexa.encode ())
  |&gt; fun md5 -&gt; printf "MD5 (%s) = %s\n" filename md5

let command =
  Command.basic
    ~summary:"Generate an MD5 hash of the input data"
    ~readme:(fun () -&gt; "More detailed information")
    Command.Spec.(empty +&gt; anon (sequence ("filename" %: file)))
    (fun files () -&gt;
       match files with
       | [] -&gt; do_hash "-" In_channel.stdin
       | _  -&gt;
         List.iter files ~f:(fun file -&gt;
           In_channel.with_file ~f:(do_hash file) file
         )
    )

let () =
  Command.run ~version:"1.0" ~build_info:"RWO" command</code></pre></div>

          <p>
	    The callback function is a little more complex now, to
            handle the extra options. The <code>files</code> are now a
            <code>string list</code>, and an empty list reverts to
            using standard input, just as our previous
            <code>maybe</code> and <code>maybe_with_default</code>
            examples did. If the list of files isn't empty, then it
            opens up each file and runs them through
            <code>do_hash</code> sequentially.</p>
	</section>
      </section>

      <section id="adding-labeled-flags-to-the-command-line" data-type="sect1">
	<h1>Adding Labeled Flags to the Command Line</h1>

	<p>
	  You aren't just limited to anonymous arguments on the
	  command line. A <em>flag</em> is a named field that can be
	  followed by an optional argument. These flags can appear in
	  any order on the command line, or multiple times, depending
	  on how they're declared in the specification.

	  <a data-type="indexterm" data-primary="flags">&nbsp;</a>
	  <a data-type="indexterm" data-primary="command-line parsing" data-secondary="labeled flags and">&nbsp;</a></p>

	<p>
	  Let's add two arguments to our <code>md5</code> command
	  that mimics the Mac OS X version. A <code>-s</code> flag
	  specifies the string to be hashed directly on the command
	  line and <code>-t</code> runs a self-test. The complete
	  example follows:</p>

	TODO: build_basic_md5_with_flags.sh
  <div class="highlight"><pre><code class="language-ocaml">(executable ((name basic_md5_with_flags) (libraries (core cryptokit))))
</code></pre></div>
	<div class="highlight"><pre><code class="language-ocaml">$ jbuilder build basic_md5_with_flags.exe
    ocamldep basic_md5_with_flags.depends.ocamldep-output
      ocamlc basic_md5_with_flags.{cmi,cmo,cmt}
    ocamlopt basic_md5_with_flags.{cmx,o}
    ocamlopt basic_md5_with_flags.exe
ld: warning: directory not found for option '-L/opt/local/lib'
</code></pre></div>
	<div class="highlight"><pre><code class="language-ocaml">open Core
open Cryptokit

let checksum_from_string buf =
  hash_string (Hash.md5 ()) buf
  |&gt; transform_string (Hexa.encode ())
  |&gt; print_endline

let checksum_from_file filename =
  let ic = match filename with
    | "-" -&gt; In_channel.stdin
    | _   -&gt; In_channel.create ~binary:true filename
  in
  hash_channel (Hash.md5 ()) ic
  |&gt; transform_string (Hexa.encode ())
  |&gt; print_endline

let command =
  Command.basic_spec
    ~summary:"Generate an MD5 hash of the input data"
    Command.Spec.(
      empty
      +&gt; flag "-s" (optional string) ~doc:"string Checksum the given string"
      +&gt; flag "-t" no_arg ~doc:" run a built-in time trial"
      +&gt; anon (maybe_with_default "-" ("filename" %: file))
    )
    (fun use_string trial filename () -&gt;
       match trial with
       | true -&gt; printf "Running time trial\n"
       | false -&gt; begin
           match use_string with
           | Some buf -&gt; checksum_from_string buf
           | None -&gt; checksum_from_file filename
         end
    )

let () = Command.run command</code></pre></div>

	<p>
	  The specification now uses the <code>flag</code> function
	  to define the two new labeled, command-line arguments. The
	  <code>doc</code> string is formatted so that the first word
	  is the short name that appears in the usage text, with the
	  remainder being the full help text. Notice that the
	  <code>-t</code> flag has no argument, and so we prepend its
	  <code>doc</code> text with a blank space. The help text for
	  the preceding code looks like this:</p>

	<div class="highlight"><pre><code class="language-ocaml">$ ./_build/default/basic_md5_with_flags.exe -help
Generate an MD5 hash of the input data

  basic_md5_with_flags.exe [FILENAME]

=== flags ===

  [-s string]    Checksum the given string
  [-t]           run a built-in time trial
  [-build-info]  print info about this build and exit
  [-version]     print the version of this build and exit
  [-help]        print this help text and exit
                 (alias: -?)

$ ./_build/default/basic_md5_with_flags.exe -s "ocaml rocks"
5a118fe92ac3b6c7854c595ecf6419cb
</code></pre></div>

	<p>
	  The <code>-s</code> flag in our specification requires a
	  <code>string</code> argument and isn't optional. The Command
	  parser outputs an error message if the flag isn't supplied,
	  as with the anonymous arguments in earlier examples. <a href="14-command-line-parsing.html#table14-2" data-type="xref">Table14 2</a> contains a list of some of the functions
	  that you can wrap flags in to control how they are
	  parsed.

	  <a data-type="indexterm" data-primary="flag functions">&nbsp;</a></p>

	<table id="table14-2">
          <caption>
            Flag functions
          </caption>

          <thead>
            <tr>
              <th>Flag function</th>

              <th>OCaml type</th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td><code>required</code> <em>arg</em></td>

              <td><em>arg</em> and error if not present</td>
            </tr>

            <tr>
              <td><code>optional</code> <em>arg</em></td>

              <td><em>arg</em> <code>option</code></td>
            </tr>

            <tr>
              <td><code>optional_with_default</code> <em>val</em>
		<em>arg</em></td>

              <td><em>arg</em> with default <em>val</em> if not
		present</td>
            </tr>

            <tr>
              <td><code>listed</code> <em>arg</em></td>

              <td><em>arg</em> <code>list</code>, flag may appear
		multiple times</td>
            </tr>

            <tr>
              <td><code>no_arg</code></td>

              <td><code>bool</code> that is true if flag is
		present</td>
            </tr>
          </tbody>
	</table>

	<p>
	  The flags affect the type of the callback function in
	  exactly the same way as anonymous arguments do. This lets you
	  change the specification and ensure that all the callback
	  functions are updated appropriately, without runtime
	  errors.</p>
      </section>

      <section id="grouping-sub-commands-together" data-type="sect1">
	<h1>Grouping Subcommands Together</h1>

	<p>
	  You can get pretty far by using flags and anonymous
	  arguments to assemble complex, command-line interfaces. After
	  a while, though, too many options can make the program very
	  confusing for newcomers to your application. One way to solve
	  this is by grouping common operations together and adding
	  some hierarchy to the command-line interface.

	  <a data-type="indexterm" data-primary="subcommands, grouping of">&nbsp;</a>
	  <a data-type="indexterm" data-primary="OPAM package manager">&nbsp;</a>
	  <a data-type="indexterm" data-primary="command-line parsing" data-secondary="subcommand grouping">&nbsp;</a></p>

	<p>
	  You'll have run across this style already when using the
	  OPAM package manager (or, in the non-OCaml world, the Git or
	  Mercurial commands). OPAM exposes commands in this form:</p>

	<div class="highlight"><pre><code class="language-ocaml">$ opam config env
$ opam remote list -k git
$ opam install --help
$ opam install cryptokit --verbose
</code></pre></div>

	<p>
	  The <code>config</code>, <code>remote</code>, and
	  <code>install</code> keywords form a logical grouping of
	  commands that factor out a set of flags and arguments. This
	  lets you prevent flags that are specific to a particular
	  subcommand from leaking into the general configuration
	  space.

	  <a data-type="indexterm" data-primary="install keyword">&nbsp;</a>
	  <a data-type="indexterm" data-primary="remote keyword">&nbsp;</a></p>

	<p>
	  This usually only becomes a concern when your application
	  organically grows features. Luckily, it's simple to extend
	  your application to do this in Command: just swap the
	  <code>Command.basic</code> for <code>Command.group</code>,
	  which takes an association list of specifications and handles
	  the subcommand parsing and help output for you:

	  <a data-type="indexterm" data-primary="Command.group">&nbsp;</a></p>

	<div class="highlight"><pre><code class="language-ocaml"># open Core;;</code></pre><pre><code class="language-ocaml"># Command.basic ;;</code></pre><pre class="ge"><code class="language-ocaml">- : unit Command.basic_command = &lt;fun&gt;</code></pre><pre><code class="language-ocaml"># Command.group ;;</code></pre><pre class="ge"><code class="language-ocaml">
- : summary:string -&gt;
    ?readme:(unit -&gt; string) -&gt;
    ?preserve_subcommand_order:unit -&gt;
    ?body:(path:string list -&gt; unit) -&gt;
    (string * Command.t) list -&gt; Command.t
= &lt;fun&gt;
</code></pre></div>

	<p>
	  The <code>group</code> signature accepts a list of basic
	  <code>Command.t</code> values and their corresponding names.
	  When executed, it looks for the appropriate subcommand from
	  the name list, and dispatches it to the right command
	  handler.</p>

	<p>
	  Let's build the outline of a calendar tool that does a few
	  operations over dates from the command line. We first need to
	  define a command that adds days to an input date and prints
	  the resulting date:</p>

	<div class="highlight"><pre><code class="language-ocaml">open Core

let add =
  Command.basic
    ~summary:"Add [days] to the [base] date and print day"
    Command.Spec.(
      empty
      +&gt; anon ("base" %: date)
      +&gt; anon ("days" %: int)
    )
    (fun base span () -&gt;
       Date.add_days base span
       |&gt; Date.to_string
       |&gt; print_endline
    )

let () = Command.run add</code></pre></div>

	<p>
	  Everything in this command should be familiar to you by
	  now. Once you've tested it and made sure it works, we can
	  define another new command that takes the difference of two
	  dates. However, instead of creating a new binary, we group
	  both operations as subcommands using
	  <code>Command.group</code>:</p>

	<div class="highlight"><pre><code class="language-ocaml">open Core

let add =
  Command.basic_spec ~summary:"Add [days] to the [base] date"
    Command.Spec.(
      empty
      +&gt; anon ("base" %: date)
      +&gt; anon ("days" %: int)
    )
    (fun base span () -&gt;
       Date.add_days base span
       |&gt; Date.to_string
       |&gt; print_endline
    )

let diff =
  Command.basic_spec ~summary:"Show days between [date1] and [date2]"
    Command.Spec.(
      empty
      +&gt; anon ("date1" %: date)
      +&gt; anon ("date2" %: date)
    )
    (fun date1 date2 () -&gt;
       Date.diff date1 date2
       |&gt; printf "%d days\n"
    )

let command =
  Command.group ~summary:"Manipulate dates"
    [ "add", add; "diff", diff ]

let () = Command.run command</code></pre></div>

	<p>
	  And that's all you really need to add subcommand support!
	  Let's build the example first in the usual way and inspect
	  the help output, which now reflects the subcommands we just
	  added.</p>
  <div class="highlight"><pre><code class="language-ocaml">(executable ((name cal_add_sub_days) (libraries (core))))
</code></pre></div>
	<div class="highlight"><pre><code class="language-ocaml">$ jbuilder build cal_add_sub_days.exe
    ocamldep cal_add_sub_days.depends.ocamldep-output
      ocamlc cal_add_sub_days.{cmi,cmo,cmt}
    ocamlopt cal_add_sub_days.{cmx,o}
    ocamlopt cal_add_sub_days.exe
$ ./_build/default/cal_add_sub_days.exe -help
Manipulate dates

  cal_add_sub_days.exe SUBCOMMAND

=== subcommands ===

  add      Add [days] to the [base] date
  diff     Show days between [date1] and [date2]
  version  print version information
  help     explain a given subcommand (perhaps recursively)

</code></pre></div>

	<p>
	  We can invoke the two commands we just defined to verify
	  that they work and see the date parsing in action:</p>

	<div class="highlight"><pre><code class="language-ocaml">$ ./_build/default/cal_add_sub_days.exe add 2012-12-25 40
2013-02-03
$ ./_build/default/cal_add_sub_days.exe diff 2012-12-25 2012-11-01
54 days
</code></pre></div>
      </section>

      <section id="advanced-control-over-parsing" data-type="sect1">
	<h1>Advanced Control over Parsing</h1>

	<p>
	  The functions for generating a specification may seem like
	  magic. In particular, even if you know how to use them, it's
	  not entirely clear how they work, and in particular, why the
	  types work out the way they do.

	  <a data-type="indexterm" data-primary="command-line parsing" data-secondary="advanced control over" id="CLPadv">&nbsp;</a></p>

	<p>
	  Understanding the details of how these specifications fit
	  together becomes more useful as your command-line interfaces
	  get more complex. In particular, you may want to factor out
	  common functionality between specifications or interrupt the
	  parsing to perform special processing, such as requesting an
	  interactive passphrase from the user before proceeding. All
	  of this is helped by a deeper understanding of the Command
	  library.</p>

	<p>
	  In the following sections we'll explain the logic behind
	  the combinators we've already described and show you some new
	  combinators that let you use Command even more
	  effectively.</p>

	<section id="the-types-behind-command.spec" data-type="sect2">
          <h2>The Types Behind Command.Spec</h2>

          <p>
	    The Command module's safety relies on the
            specification's output values precisely matching the
            callback function which invokes the main program. In order
            to prevent any such mismatches, Command uses some
            interesting type machinery to guarantee they remain in
            sync. You don't have to understand this section to use the
            more advanced combinators, but it'll help you debug type
            errors as you use Command more.

	    <a data-type="indexterm" data-primary="callback function">&nbsp;</a>
	    <a data-type="indexterm" data-primary="debugging" data-secondary="Command mode">&nbsp;</a>
	    <a data-type="indexterm" data-primary="Command module">&nbsp;</a></p>

          <p>
	    The <code>Command.Spec.t</code> type looks deceptively
            simple: <code>('a, 'b) t</code>. You can think of
            <code>('a, 'b) t</code> here as a function of type <code>'a
              -&gt; 'b</code>, but embellished with information
            about:</p>

          <ul>
            <li>
              <p>
		How to parse the command line</p>
            </li>

            <li>
              <p>
		What the command does and how to call it</p>
            </li>

            <li>
              <p>
		How to autocomplete a partial command line</p>
            </li>
          </ul>

          <p>
	    The type of a specification transforms a <code>'a</code>
            to a <code>'b</code> value. For instance, a value of
            <code>Spec.t</code> might have type <code>(arg1 -&gt; ...
              -&gt; argN -&gt; 'r, 'r) Spec.t</code>.</p>

          <p>
	    Such a value transforms a main function of type
            <code>arg1 -&gt; ... -&gt; argN -&gt; 'r</code> by
            supplying all the argument values, leaving a main function
            that returns a value of type <code>'r</code>. Let's look at
            some examples of specs, and their types:</p>

          <div class="highlight"><pre><code class="language-ocaml"># Command.Spec.empty ;;</code></pre><pre class="ge"><code class="language-ocaml">- : ('m, 'm) Command.Spec.t = &lt;abstr&gt;</code></pre><pre><code class="language-ocaml"># Command.Spec.(empty +&gt; anon ("foo" %: int)) ;;</code></pre><pre class="ge"><code class="language-ocaml">- : (int -&gt; '_a, '_a) Command.Spec.t = &lt;abstr&gt;</code></pre></div>

          <p>
	    The empty specification is simple, as it doesn't add any
            parameters to the callback type. The second example adds an
            <code>int</code> anonymous parameter that is reflected in
            the inferred type. One forms a command by combining a spec
            of type <code>('main, unit) Spec.t</code> with a function
            of type <code>'main</code>. The combinators we've shown so
            far incrementally build the type of <code>'main</code>
            according to the command-line parameters it expects, so the
            resulting type of <code>'main</code> is something like
            <code>arg1 -&gt; ... -&gt; argN -&gt; unit</code>.</p>

          <p>
	    The type of <code>Command.basic</code> should make more
            sense now:</p>

          <div class="highlight"><pre><code class="language-ocaml"># Command.basic;;</code></pre><pre class="ge"><code class="language-ocaml">- : unit Command.basic_command = &lt;fun&gt;</code></pre></div>

          <p>
	    The parameters to <code>Spec.t</code> are important
            here. They show that the callback function for a spec
            should consume identical arguments to the supplied
            <code>main</code> function, except for an additional
            <code>unit</code> argument. This final <code>unit</code> is
            there to make sure the callback is evaluated as a function,
            since if zero command-line arguments are specified (i.e.,
            <span class="keep-together"><code>Spec.empty</code></span>), the
            callback would otherwise have no arguments and be evaluated
            immediately. That's why you have to supply an additional
            <code>()</code> to the callback function in all the
            previous examples.</p>
	</section>

	<section id="composing-specification-fragments-together" data-type="sect2">
          <h2>Composing Specification Fragments Together</h2>

          <p>
	    If you want to factor out common command-line
            operations, the <code>++</code> operator will append two
            specifications together. Let's add some dummy verbosity and
            debug flags to our calendar application to illustrate
            this.</p>

          <div class="highlight"><pre><code class="language-ocaml">open Core

let add ~common =
  Command.basic ~summary:"Add [days] to the [base] date"
    Command.Spec.(
      empty
      +&gt; anon ("base" %: date)
      +&gt; anon ("days" %: int)
      ++ common
    )
    (fun base span debug verbose () -&gt;
       Date.add_days base span
       |&gt; Date.to_string
       |&gt; print_endline
    )

let diff ~common =
  Command.basic ~summary:"Show days between [date2] and [date1]"
    Command.Spec.(
      empty
      +&gt; anon ("date1" %: date)
      +&gt; anon ("date2" %: date)
      ++ common
    )
    (fun date1 date2 debug verbose () -&gt;
       Date.diff date1 date2
       |&gt; printf "%d days\n"
    )

</code></pre></div>

          <p>
	    The definitions of the specifications are very similar
            to the earlier example, except that they append a
            <code>common</code> parameter after each specification. We
            can supply these flags when defining the groups.</p>

          <div class="highlight"><pre><code class="language-ocaml">let () =
  let common =
    Command.Spec.(
      empty
      +&gt; flag "-d" (optional_with_default false bool) ~doc:" Debug mode"
      +&gt; flag "-v" (optional_with_default false bool) ~doc:" Verbose output"
    )
  in
  List.map ~f:(fun (name, cmd) -&gt; (name, cmd ~common))
    [ "add", add; "diff", diff ]
  |&gt; Command.group ~summary:"Manipulate dates"
  |&gt; Command.run</code></pre></div>

          <p>
	    Both of these flags will now be applied and passed to
            all the callback functions. This makes code refactoring a
            breeze by using the compiler to spot places where you use
            commands. Just add a parameter to the common definition,
            run the compiler, and fix type errors until everything
            works again.

	    <a data-type="indexterm" data-primary="refactoring">&nbsp;</a></p>

          <p>
	    For example, if we remove the <code>verbose</code> flag
            and recompile, we'll get this impressively long type
            error:</p>
          <div class="highlight"><pre><code class="language-ocaml">(executable ((name cal_append_broken) (libraries (core))))
</code></pre></div>
          <div class="highlight"><pre><code class="language-ocaml">$ jbuilder build cal_append_broken.exe
Error: exception Sys_error("jbuild.inc: No such file or directory")
Backtrace:
Raised by primitive operation at file "pervasives.ml", line 389, characters 28-54
Called from file "src/io.ml", line 15, characters 11-31
Called from file "src/jbuild.ml", line 979, characters 22-71
Called from file "src/sexp.ml", line 339, characters 36-48
Called from file "list.ml", line 82, characters 20-23
Called from file "src/import.ml" (inlined), line 68, characters 31-41
Called from file "src/jbuild.ml", line 1005, characters 4-71
Called from file "src/jbuild.ml", line 1009, characters 6-63
Called from file "src/jbuild_load.ml", line 164, characters 33-64
Called from file "src/jbuild_load.ml", line 224, characters 23-44
Called from file "src/jbuild_load.ml", line 234, characters 16-58
Called from file "src/main.ml", line 26, characters 13-56
Called from file "bin/main.ml", line 547, characters 7-29
Called from file "vendor/cmdliner/src/cmdliner_term.ml", line 27, characters 19-24
Called from file "vendor/cmdliner/src/cmdliner.ml", line 106, characters 32-39
Called from file "vendor/cmdliner/src/cmdliner.ml", line 136, characters 18-36
Called from file "vendor/cmdliner/src/cmdliner.ml", line 251, characters 22-48
Called from file "bin/main.ml", line 1176, characters 10-51
</code></pre></div>

          <p>
	    While this does look scary, the key line to scan is the
            last one, where it's telling you that you have supplied too
            many arguments in the callback function (<code>unit -&gt;
              unit</code> versus <code>unit</code>). If you started with
            a working program and made this single change, you
            typically don't even need to read the type error, as the
            filename and location information is sufficient to make the
            obvious fix.</p>
	</section>

	<section id="prompting-for-interactive-input" data-type="sect2">
          <h2>Prompting for Interactive Input</h2>

          <p>
	    The <code>step</code> combinator lets you control the
            normal course of parsing by supplying a function that maps
            callback arguments to a new set of values. For instance,
            let's revisit our first calendar application that added a
            number of days onto a supplied base date:

	    <a data-type="indexterm" data-primary="interactive input" data-secondary="prompts for">&nbsp;</a></p>

          <div class="highlight"><pre><code class="language-ocaml">open Core

let add =
  Command.basic
    ~summary:"Add [days] to the [base] date and print day"
    Command.Spec.(
      empty
      +&gt; anon ("base" %: date)
      +&gt; anon ("days" %: int)
    )
    (fun base span () -&gt;
       Date.add_days base span
       |&gt; Date.to_string
       |&gt; print_endline
    )

let () = Command.run add</code></pre></div>

          <p>
	    This program requires you to specify both the
            <code>base</code> date and the number of <code>days</code>
            to add onto it. If <code>days</code> isn't supplied on the
            command line, an error is output. Now let's modify it to
            interactively prompt for a number of days if only the
            <code>base</code> date is supplied:</p>

          <div class="highlight"><pre><code class="language-ocaml">open Core

let add_days base span () =
  Date.add_days base span
  |&gt; Date.to_string
  |&gt; print_endline

let add =
  Command.basic_spec
    ~summary:"Add [days] to the [base] date and print day"
    Command.Spec.(
      step
        (fun m base days -&gt;
           match days with
           | Some days -&gt;
             m base days
           | None -&gt;
             print_endline "enter days: ";
             Int.of_string In_channel.(input_line_exn stdin)
             |&gt; m base
        )
      +&gt; anon ("base" %: date)
      +&gt; anon (maybe ("days" %: int))
    )
    add_days

let () = Command.run add</code></pre></div>

          <p>
	    The <code>days</code> anonymous argument is now an
            optional integer in the spec, and we want to transform it
            into a nonoptional value before calling our
            <code>add_days</code> callback. The <code>step</code>
            combinator lets us perform this transformation by applying
            its supplied callback function first. In the example, the
            callback first checks if <code>days</code> is defined. If
            it's undefined, then it interactively reads an integer from
            the standard input.</p>

          <p>
	    The first <code>m</code> argument to the
            <code>step</code> callback is the next callback function in
            the chain. The transformation is completed by calling
            <code>m base days</code> to continue processing with the
            new values we've just calculated. The <code>days</code>
            value that is passed onto the next callback now has a
            nonoptional <code>int</code> type:</p>

          <div class="highlight"><pre><code class="language-ocaml">$ jbuilder build cal_add_interactive.exe
    ocamldep cal_add_interactive.depends.ocamldep-output
      ocamlc cal_add_interactive.{cmi,cmo,cmt}
    ocamlopt cal_add_interactive.{cmx,o}
    ocamlopt cal_add_interactive.exe
$ echo 35 | ./_build/default/cal_add_interactive.exe 2013-12-01
enter days: 
2014-01-05
</code></pre></div>

          <p>
	    The transformation means that the <code>add_days</code>
            callback can just keep its original definition of
            <code>Date.t -&gt; int -&gt; unit</code>. The
            <code>step</code> function transformed the <code>int
              option</code> argument from the parsing into an
            <code>int</code> suitable for <code>add_days</code>. This
            transformation is explicitly represented in the type of the
            <code>step</code> return value:</p>

          <div class="highlight"><pre><code class="language-ocaml"># open Command.Spec ;;</code></pre><pre><code class="language-ocaml"># step (fun m (base:Date.t) days -&gt;
    match days with
    | Some days -&gt; m base days
    | None -&gt;
      print_endline "enter days: ";
      m base (read_int ())) ;;</code></pre><pre class="ge"><code class="language-ocaml">
Characters 139-147:
Warning 3: deprecated: Core.read_int
[since 2016-04] Use
[Out_channel.(flush stdout); Int.of_string In_channel.(input_line_exn stdin)]
</code></pre><pre class="ge"><code class="language-ocaml">- : (Date.t -&gt; int -&gt; '_a, Date.t -&gt; int option -&gt; '_a) t = &lt;abstr&gt;</code></pre></div>

          <p>
	    The first half of the <code>Spec.t</code> shows that the
            callback type is <code>Date.t -&gt; int</code>, whereas the
            resulting value expected from the next specification in the
            chain is a <code>Date.t -&gt; int option</code>.</p>
	</section>

	<section id="adding-labeled-arguments-to-callbacks" data-type="sect2">
          <h2>Adding Labeled Arguments to Callbacks</h2>

          <p>
	    The <code>step</code> chaining lets you control the
            types of your callbacks very easily. This can help you
            match existing interfaces or make things more explicit by
            adding labeled arguments:

	    <a data-type="indexterm" data-primary="callback function">&nbsp;</a>
	    <a data-type="indexterm" data-primary="arguments" data-secondary="labeled arguments">&nbsp;</a>
	    <a data-type="indexterm" data-primary="labeled arguments">&nbsp;</a></p>

          <div class="highlight"><pre><code class="language-ocaml">open Core

let add_days ~base_date ~num_days () =
  Date.add_days base_date num_days
  |&gt; Date.to_string
  |&gt; print_endline

let add =
  Command.basic
    ~summary:"Add [days] to the [base] date and print day"
    Command.Spec.( 
      step (fun m base days -&gt; m ~base_date:base ~num_days:days)
      +&gt; anon ("base" %: date)
      +&gt; anon ("days" %: int)
    )
    add_days

let () = Command.run add</code></pre></div>

          <p>
	    This <code>cal_add_labels</code> example goes back to
            our noninteractive calendar addition program, but the
            <code>add_days</code> main function now expects labeled
            arguments. The <code>step</code> <span class="keep-together">function</span> in the specification simply
            converts the default <code>base</code> and
            <code>days</code> arguments into a labeled function.</p>

          <p>
	    Labeled arguments are more verbose but can also help
            prevent errors with command-line arguments with similar
            types but different names and purposes. It's good form to
            use labels when you have a lot of otherwise anonymous
            <code>int</code> and <code>string</code> arguments.
            <a data-type="indexterm" data-startref="CLPadv">&nbsp;</a></p>
	</section>
      </section>

      <section id="command-line-auto-completion-with-bash" data-type="sect1">
	<h1>Command-Line Autocompletion with bash</h1>

	<p>
	  Modern UNIX shells usually have a tab-completion feature
	  to interactively help you figure out how to build a command
	  line. These work by pressing the Tab key in the middle of
	  typing a command, and seeing the options that pop up. You've
	  probably used this most often to find the files in the
	  current directory, but it can actually be extended for other
	  parts of the command, too.

	  <a data-type="indexterm" data-primary="tab-autocompletion">&nbsp;</a>
	  <a data-type="indexterm" data-primary="autocompletion">&nbsp;</a>
	  <a data-type="indexterm" data-primary="command-line parsing" data-secondary="autocompletion with bash">&nbsp;</a></p>

	<p>
	  The precise mechanism for autocompletion varies depending
	  on what shell you are using, but we'll assume you are using
	  the most common one: <span class="command"><em>bash</em></span>. This is the default
	  interactive shell on most Linux distributions and Mac OS X,
	  but you may need to switch to it on *BSD or Windows (when
	  using Cygwin). The rest of this section assumes that you're
	  using <span class="command"><em>bash</em></span>.

	  <a data-type="indexterm" data-primary="bash autocompletion">&nbsp;</a></p>

	<p>
	  Bash autocompletion isn't always installed by default, so
	  check your OS package manager to see if you have it
	  available.</p>

	<table>
          <thead>
            <tr>
              <th>Operating system</th>

              <th>Package manager</th>

              <th>Package</th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td>Debian Linux</td>

              <td><code>apt</code></td>

              <td><code>bash-completion</code></td>
            </tr>

            <tr>
              <td>Mac OS X</td>

              <td>Homebrew</td>

              <td><code>bash-completion</code></td>
            </tr>

            <tr>
              <td>FreeBSD</td>

              <td>Ports system</td>

              <td><em class="filename">/usr/ports/shells/bash-completion</em></td>
            </tr>
          </tbody>
	</table>

	<p>
	  Once <em>bash</em> completion is installed and configured,
	  check that it works by typing the <code>ssh</code> command
	  and pressing the Tab key. This should show you the list of
	  known hosts from your <em>~/.ssh/known_hosts</em> file. If it
	  lists some hosts that you've recently connected to, you can
	  continue on. If it lists the files in your current directory
	  instead, then check your OS documentation to configure
	  completion correctly.</p>

	<p>
	  One last bit of information you'll need to find is the
	  location of the <em class="filename">bash_completion.d</em>
	  directory. This is where all the shell fragments that contain
	  the completion logic are held. On Linux, this is often in
	  <em class="filename">/etc/bash_completion.d</em>, and in
	  Homebrew on Mac OS X, it would be <em class="filename">/usr/local/etc/bash_completion.d</em> by
	  default.</p>

	<section id="generating-completion-fragments-from-command" data-type="sect2">
          <h2>Generating Completion Fragments from Command</h2>

          <p>
	    The Command library has a declarative description of all
            the possible valid options, and it can use this information
            to generate a shell script that provides completion support
            for that command. To generate the fragment, just run the
            command with the
            <code>COMMAND_OUTPUT_INSTALLATION_BASH</code> environment
            variable set to any value.</p>

          <p>
	    For example, let's try it on our MD5 example from
            earlier, assuming that the binary is called <span class="command"><em>basic_md5_with_flags</em></span> in the
            current directory:</p>

          <div class="highlight"><pre><code class="language-ocaml">$ env COMMAND_OUTPUT_INSTALLATION_BASH=1 ./_build/default/basic_md5_with_flags.exe
function _jsautocom_26035 {
  export COMP_CWORD
  COMP_WORDS[0]=./_build/default/basic_md5_with_flags.exe
  if type readarray &gt; /dev/null
  then readarray -t COMPREPLY &lt; &lt;("${COMP_WORDS[@]}")
  else IFS="
" read -d " " -A COMPREPLY &lt; &lt;("${COMP_WORDS[@]}")
  fi
}
complete -F _jsautocom_26035 ./_build/default/basic_md5_with_flags.exe
</code></pre></div>

          <p>
	    Recall that we used the <code>Arg_type.file</code> to
            specify the argument type. This also supplies the
            completion logic so that you can just press Tab to complete
            files in your current directory.</p>
	</section>

	<section id="installing-the-completion-fragment" data-type="sect2">
          <h2>Installing the Completion Fragment</h2>

          <p>
	    You don't need to worry about what the preceding output
            script actually does (unless you have an unhealthy
            fascination with shell scripting internals, that is).
            Instead, redirect the output to a file in your current
            directory and source it into your current shell:</p>

          <div class="highlight"><pre><code class="language-ocaml">$ env COMMAND_OUTPUT_INSTALLATION_BASH=1 ./cal_add_sub_days.native &gt; cal.cmd
$ . cal.cmd
$ ./cal_add_sub_days.native &lt;tab&gt;
add      diff     help     version
</code></pre></div>

          <p>
	    Command completion support works for flags and grouped
            commands and is very useful when building larger
            command-line interfaces. Don't forget to install the shell
            fragment into your
            global <em class="filename">bash_completion.d</em>
            directory if you want it to be loaded in all of your login
            shells.

	    <a data-type="indexterm" data-primary="completion handlers">&nbsp;</a></p>

          <div data-type="note">
            <h1>Installing a Generic Completion Handler</h1>

            <p>
	      Sadly, <span class="command"><em>bash</em></span>
              doesn't support installing a generic handler for all
              Command-based applications. This means you have to
              install the completion script for every application, but
              you should be able to automate this in the build and
              packaging system for your application.</p>

            <p>
	      It will help to check out how other applications
              install tab-completion scripts and follow their lead, as
              the details are very OS-specific.</p>
          </div>
	</section>
      </section>

      <section id="alternative-command-line-parsers" data-type="sect1">
	<h1>Alternative Command-Line Parsers</h1>

	<p>
	  This rounds up our tour of the Command library. This isn't
	  the only way to parse command-line arguments of course; there
	  are several alternatives available on OPAM. Three of the most
	  prominent ones follow:

	  <a data-type="indexterm" data-primary="Cmdliner">&nbsp;</a>
	  <a data-type="indexterm" data-primary="OCaml toolchain" data-secondary="ocaml-getopt">&nbsp;</a>
	  <a data-type="indexterm" data-primary="Arg module">&nbsp;</a>
	  <a data-type="indexterm" data-primary="command-line parsing" data-secondary="alternatives to Command library">&nbsp;</a>
	  <a data-type="indexterm" data-primary="OPAM package manager">&nbsp;</a></p>

	<dl>
          <dt>The <code>Arg</code> module</dt>

          <dd>
            <p>
	      The <code>Arg</code> module is from the OCaml standard
              library, which is used by the compiler itself to handle
              its command-line interface. Command is generally more
              featureful than Arg (mainly via support for subcommands,
              the <code>step</code> combinator to transform inputs, and
              help generation), but there's absolutely nothing wrong
              with using Arg either.</p>

            <p>
	      You can use the
              <code>Command.Spec.flags_of_args_exn</code> function to
              convert Arg specifications into ones compatible with
              Command. This is quite often used to help port older
              non-Core code into the Core standard library world.</p>
          </dd>

          <dt>
            <a href="https://forge.ocamlcore.org/projects/ocaml-getopt/">ocaml-getopt</a>
          </dt>

          <dd>
            <p>
	      <code>ocaml-getopt</code> provides the general
              command-line syntax of GNU <code>getopt</code> and
              <code>getopt_long</code>. The GNU conventions are widely
              used in the open source world, and this library lets your
              OCaml programs obey the same rules.</p>
          </dd>

          <dt>
            <a href="http://erratique.ch/software/cmdliner">Cmdliner</a>
          </dt>

          <dd>
            <p>
	      Cmdliner is a mix between the Command and Getopt
              libraries. It allows for the declarative definition of
              command-line interfaces but exposes a more
              <code>getopt</code>-like interface. It also automates the
              generation of UNIX man pages as part of the
              specification. Cmdliner is the parser used by OPAM to
              manage its command line.</p>
          </dd>
	</dl>
      </section>
    </section>
  </article></div><a class="next-chapter" href="15-json.html"><div class="content"><h1><small>Next: Chapter 15</small>Handling JSON Data</h1></div></a><footer><div class="content"><ul><li><a href="http://twitter.com/realworldocaml">@realworldocaml</a></li><li><a href="http://twitter.com/yminsky">@yminsky</a></li><li><a href="http://twitter.com/avsm">@avsm</a></li><li><a href="https://plus.google.com/111219778721183890368">+hickey</a></li><li><a href="https://github.com/realworldocaml">GitHub</a></li><li><a href="http://www.goodreads.com/book/show/16087552-real-world-ocaml">goodreads</a></li></ul><p>Copyright 2012-2014 Jason Hickey, Anil Madhavapeddy and Yaron Minsky.</p></div></footer><script src="js/jquery.min.js"></script><script src="js/min/app-min.js"></script><script src="js/discourse.js"></script></body></html>