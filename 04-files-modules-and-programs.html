<html class="js flexbox fontface" lang="en" style=""><head><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Real World OCaml</title><link rel="stylesheet" href="css/app.css"/><link rel="stylesheet" href="css/prism.css"/><script src="js/min/modernizr-min.js"></script><script src="js/prism.js"></script><script src="//use.typekit.net/gfj8wez.js"></script><script>try{Typekit.load();}catch(e){}</script></head></head><body><div class="title-bar"><div class="title"><h1>Real World OCaml</h1><h5>2<sup>nd</sup> Edition (in progress)</h5><nav><a href="index.html">Home</a><a href="toc.html">Table of Contents</a><a href="faqs.html">FAQs</a><a href="install.html">Install</a><a href="https://ocaml.janestreet.com/ocaml-core/">API Docs</a></nav></div></div><div class="wrap"><div class="left-column"><a href="toc.html" class="to-chapter"><small>Back</small><h5>Table of Contents</h5></a></div><article class="main-body">
  <section xmlns="http://www.w3.org/1999/xhtml" id="files-modules-and-programs" data-type="chapter">
    <h1>Files, Modules, and Programs</h1>

    <p>We've so far experienced OCaml largely through the toplevel.
    As you move from exercises to real-world programs, you'll need
    to leave the toplevel behind and start building programs from
    files. Files are more than just a convenient way to store and
    manage your code; in OCaml, they also correspond to modules,
    which act as boundaries that divide your program into
    conceptual units.</p>

    <p>In this chapter, we'll show you how to build an OCaml
    program from a collection of files, as well as the basics of
    working with modules and module signatures.</p>

    <section id="single-file-programs" data-type="sect1">
      <h1>Single-File Programs</h1>

      <p>We'll start with an example: a utility that reads lines
      from <code>stdin</code> and computes a frequency count of the
      lines, and prints out the ten most frequent lines. We'll start
      with a simple implementation, which we'll save as the
      file <em>freq.ml</em>.

      <a data-type="indexterm" data-primary="files" data-secondary="single-file programs" id="FILEsnglprog">&nbsp;</a>
      <a data-type="indexterm" data-primary="programs" data-secondary="single-file programs" id="Psingfil">&nbsp;</a></p>

      <p>This implementation will use two functions from
      the <code>List.Assoc</code> module, which provides utility
      functions for interacting with <em>association
      lists</em>, <em>i.e.</em>, lists of key/value pairs. In
      particular, we use the function <code>List.Assoc.find</code>,
      which looks up a key in an association list;
      and <code>List.Assoc.add</code>, which adds a new binding to an
      association list, as shown here:

      <a data-type="indexterm" data-primary="List.Assoc module" data-secondary="List.Assoc.add">&nbsp;</a>
      <a data-type="indexterm" data-primary="List.Assoc module" data-secondary="List.Assoc.find">&nbsp;</a>
      <a data-type="indexterm" data-primary="lists" data-secondary="adding new bindings in">&nbsp;</a>
      <a data-type="indexterm" data-primary="lists" data-secondary="finding key associations in">&nbsp;</a></p>

      <div class="highlight"><pre><code class="language-ocaml"># open Core_kernel;;</code></pre><pre><code class="language-ocaml"># let assoc = [("one", 1); ("two",2); ("three",3)] ;;</code></pre><pre class="ge"><code class="language-ocaml">val assoc : (string * int) list = [("one", 1); ("two", 2); ("three", 3)]</code></pre><pre><code class="language-ocaml"># List.Assoc.find ~equal:String.equal assoc "two" ;;</code></pre><pre class="ge"><code class="language-ocaml">- : int option = Some 2</code></pre><pre><code class="language-ocaml"># List.Assoc.add ~equal:String.equal assoc "four" 4 (* add a new key *) ;;</code></pre><pre class="ge"><code class="language-ocaml">
- : (string, int) Base__List.Assoc.t =
[("four", 4); ("one", 1); ("two", 2); ("three", 3)]
</code></pre><pre><code class="language-ocaml"># List.Assoc.add ~equal:String.equal assoc "two"  4 (* overwrite an existing key *) ;;</code></pre><pre class="ge"><code class="language-ocaml">- : (string, int) Base__List.Assoc.t = [("two", 4); ("one", 1); ("three", 3)]</code></pre></div>

      <p>Note that <code>List.Assoc.add</code> doesn't modify the
      original list, but instead allocates a new list with the
      requisite key/value pair added.</p>

      <p>Now we can write <code>freq.ml</code>:</p>
      <div class="highlight"><pre><code class="language-ocaml">open Core_kernel

let build_counts () =
  In_channel.fold_lines In_channel.stdin ~init:[] ~f:(fun counts line -&gt;
    let count =
      match List.Assoc.find ~equal:String.equal counts line with
      | None -&gt; 0
      | Some x -&gt; x
    in
    List.Assoc.add ~equal:String.equal counts line (count + 1)
  )

let () =
  build_counts ()
  |&gt; List.sort ~cmp:(fun (_,x) (_,y) -&gt; Int.descending x y)
  |&gt; (fun l -&gt; List.take l 10)
  |&gt; List.iter ~f:(fun (line,count) -&gt; printf "%3d: %s\n" count line)</code></pre></div>

      <p>The function <code>build_counts</code> reads in lines from
      <code>stdin</code>, constructing from those lines an
      association list with the frequencies of each line. It does
      this by invoking <code>In_channel.fold_lines</code> (similar
      to the function <code>List.fold</code> described in <a href="03-lists-and-patterns.html#lists-and-patterns" data-type="xref">Chapter 3, Lists And Patterns</a>), which reads through the lines
      one by one, calling the provided <code>fold</code> function
      for each line to update the accumulator. That accumulator is
      initialized to the empty list.</p>

      <p>With <code>build_counts</code> defined, we then call the
      function to build the association list, sort that list by
      frequency in descending order, grab the first 10 elements off
      the list, and then iterate over those 10 elements and print
      them to the screen. These operations are tied together using
      the <code>|&gt;</code> operator described in <a href="02-variables-and-functions.html#variables-and-functions" data-type="xref">Chapter 2, Variables And Functions</a>.

	<a data-type="indexterm" data-primary="let ( ) declaration">&nbsp;</a>
	<a data-type="indexterm" data-primary="main function">&nbsp;</a></p>

      <div class="allow_break" data-type="note">
        <h1>Where Is <code>main</code>?</h1>

        <p>Unlike programs in C, Java or C#, programs in OCaml do not
        have a unique <code>main</code> function. When an OCaml
        program is evaluated, all the statements in the implementation
        files are evaluated in the order in which they were linked
        together. These implementation files can contain arbitrary
        expressions, not just function definitions. In this example,
        the declaration starting with <code>let () =</code> plays the
        role of the <code>main</code> function, kicking off the
        processing. But really the entire file is evaluated at
        startup, and so in some sense the full codebase is one
        big <code>main</code> function.</p>

        <p>The idiom of writing <code>let () =</code> may seem a
        bit odd, but it has a purpose. The <code>let</code> binding
        here is a pattern-match to a value of type
        <code>unit</code>, which is there to ensure that the
        expression on the righthand side returns <code>unit</code>,
        as is common for functions that operate primarily by side
        effect.</p>
      </div>

      <p>If we weren't using <code>Core_kernel</code> or any other
      external libraries, we could build the executable like
      this:</p>
      <div class="highlight"><pre><code class="language-ocaml">$ ocamlc freq.ml -o freq.byte
^[[1mFile "^[[1mfreq.ml", line 1, characters 5-16^[[0m^[[0m:
^[[1;31mError^[[0m: Unbound module Core_kernel
</code></pre></div>

      <p>But as you can see, it fails because it can't find
      <code>Core_kernel</code>. We need a somewhat more complex
      invocation to get <code>Core_kernel</code> linked in:

      <a data-type="indexterm" data-primary="OCaml toolchain" data-secondary="ocamlc">&nbsp;</a>
      <a data-type="indexterm" data-primary="OCaml toolchain" data-secondary="ocamlfind">&nbsp;</a>
      <a data-type="indexterm" data-primary="Core standard library" data-secondary="finding with ocamlfind">&nbsp;</a></p>

      <div class="highlight"><pre><code class="language-ocaml">$ ocamlfind ocamlc -linkpkg -thread -package core_kernel freq.ml -o freq.byte
</code></pre></div>

      <p>This uses <span class="command"><em>ocamlfind</em></span>, a
      tool which itself invokes other parts of the OCaml toolchain (in
      this case, <span class="command"><em>ocamlc</em></span>) with
      the appropriate flags to link in particular libraries and
      packages. Here, <code>-package core</code> is
      asking <span class="command"><em>ocamlfind</em></span> to link
      in the Core library; <code>-linkpkg</code> asks ocamlfind to
      link in the packages as is necessary for building an executable,
      while <code>-thread</code> turns on threading support, which is
      required for Core.

      <a data-type="indexterm" data-primary="threads" data-secondary="turning on with -thread">&nbsp;</a>
      <a data-type="indexterm" data-primary="-linkpkg" data-primary-sortas="linkpkg">&nbsp;</a></p>

      <p>While this works well enough for a one-file project, more
	complicated projects require a tool to orchestrate the build.
	One good tool for this task
	is <span class="command"><em>jbuilder</em></span>. To
	invoke <span class="command"><em>jbuilder</em></span>, you
	need to have a <code>jbuild</code> file that specifies the
	details of the build.  <a data-type="indexterm" data-primary="jbuilder">&nbsp;</a></p>

      <div class="highlight"><pre><code class="language-ocaml">(executable ((name freq) (libraries (core_kernel))))
</code></pre></div>

      <p>With that in place, we can
	invoke <span class="command"><em>jbuilder</em></span> as
	follows.

      <div class="highlight"><pre><code class="language-ocaml">$ jbuilder build freq.bc
    ocamldep freq.depends.ocamldep-output
      ocamlc freq.{cmi,cmo,cmt}
      ocamlc freq.bc
</code></pre></div>

      <p>We can run the resulting executable, <code>freq.bc</code>,
      from the command line.  The following invocation extracts
      strings from the <span class="command"><em>ocamlopt</em></span>
      binary, reporting the most frequently occurring ones. Note that
      the specific results will vary from platform to platform, since
      the binary itself will differ between platforms.

	<a data-type="indexterm" data-primary="OCaml toolchain" data-secondary="jbuilder">&nbsp;</a>
	<a data-type="indexterm" data-primary="native-code compiler" data-secondary="vs. bytecode compiler">&nbsp;</a>
	<a data-type="indexterm" data-primary="bytecode compiler" data-secondary="vs. native-code compiler">&nbsp;</a>
	<a data-type="indexterm" data-primary="OCaml toolchain" data-secondary="ocamlopt">&nbsp;</a>
	<a data-type="indexterm" data-primary="OCaml toolchain" data-secondary="ocamlc">&nbsp;</a>
	<a data-type="indexterm" data-primary="code compilers" data-secondary="bytecode vs. native code">&nbsp;</a>
	<a data-type="indexterm" data-startref="FILEsnglprog">&nbsp;</a>
	<a data-type="indexterm" data-startref="Psingfil">&nbsp;</a>
      </p>

      <div class="highlight"><pre><code class="language-ocaml">$ strings `which ocamlopt` | ./_build/default/freq.bc
 92: &lt;hov2&gt;
 76: list.ml
 55: bytecomp/matching.ml
 53: p` &lt;
 47: typing/env.ml
 46: &lt;hov&gt;
 43: string.ml
 41: typing/ctype.ml
 40: typing/parmatch.ml
 39: utils/misc.ml
</code></pre></div>

      <div data-type="note">
        <h1>Bytecode Versus Native Code</h1>

        <p>OCaml ships with two compilers:
        the <span class="command"><em>ocamlc</em></span> bytecode
        compiler and
        the <span class="command"><em>ocamlopt</em></span> native-code
        compiler. Programs compiled
        with <span class="command"><em>ocamlc</em></span> are
        interpreted by a virtual machine, while programs compiled
        with <span class="command"><em>ocamlopt</em></span> are
        compiled to native machine code to be run on a specific
        operating system and processor
        architecture. With <span class="command"><em>jbuilder</em></span>,
        targets ending with <code>.bc</code> are built as bytecode
        executables, and those ending with <code>.exe</code> are built
        as native code.</p>

        <p>Aside from performance, executables generated by the two
        compilers have nearly identical behavior. There are a few
        things to be aware of. First, the bytecode compiler can be
        used on more architectures, and has some tools that are not
        available for native code. For example, the OCaml debugger
        only works with bytecode
        (although <span class="command"><em>gdb</em></span>, the GNU
        Debugger, works with OCaml native-code applications). The
        bytecode compiler is also quicker than the native-code
        compiler. In addition, in order to run a bytecode executable,
        you typically need to have OCaml installed on the system in
        question. That's not strictly required, though, since you can
        build a bytecode executable with an embedded runtime, using
        the <code>-custom</code> compiler flag.</p>

        <p>As a general matter, production executables should usually
        be built using the native-code compiler, but it sometimes
        makes sense to use bytecode for development builds. And, of
        course, bytecode makes sense when targeting a platform not
        supported by the native-code compiler. We'll cover both
        compilers in more detail
        in <a href="23-compiler-backend.html#the-compiler-backend-byte-code-and-native-code" data-type="xref">Chapter 23, The Compiler Backend Byte Code And Native
        Code</a>.</p>
      </div>
    </p></section>

    <section id="multi-file-programs-and-modules" data-type="sect1">
      <h1>Multifile Programs and Modules</h1>

      <p>Source files in OCaml are tied into the module system,
      with each file compiling down into a module whose name is
      derived from the name of the file. We've encountered modules
      before, such as when we used functions like <code>find</code>
      and <code>add</code> from the <code>List.Assoc</code> module.
      At its simplest, you can think of a module as a collection of
      definitions that are stored within a
      namespace.

	<a data-type="indexterm" data-primary="modules" data-secondary="basics of">&nbsp;</a>
	<a data-type="indexterm" data-primary="files" data-secondary="multi-file programs">&nbsp;</a>
	<a data-type="indexterm" data-primary="programs" data-secondary="multi-file programs">&nbsp;</a></p>

      <p>Let's consider how we can use modules to refactor the
      implementation of <code>freq.ml</code>. Remember that the
      variable <code>counts</code> contains an association list
      representing the counts of the lines seen so far. But
      updating an association list takes time linear in the length
      of the list, meaning that the time complexity of processing a
      file is quadratic in the number of distinct lines in the
      file.</p>

      <p>We can fix this problem by replacing association lists
      with a more efficient data structure. To do that, we'll first
      factor out the key functionality into a separate module with
      an explicit interface. We can consider alternative (and more
      efficient) implementations once we have a clear interface to
      program against.</p>

      <p>We'll start by creating a file, <code>counter.ml</code>, that
      contains the logic for maintaining the association list used to
      represent the frequency counts. The key function,
      called <code>touch</code>, bumps the frequency count of a given
      line by one.</p> 

      <div class="highlight"><pre><code class="language-ocaml">open Core_kernel

let touch counts line =
  let count = 
    match List.Assoc.find ~equal:String.equal counts line with
    | None -&gt; 0
    | Some x -&gt; x
  in
  List.Assoc.add ~equal:String.equal counts line (count + 1)</code></pre></div>

      <p>The file <em>counter.ml</em> will be compiled into a
      module named <code>Counter</code>, where the name of the
      module is derived automatically from the filename. The module
      name is capitalized even if the file is not. Indeed, module
      names are always capitalized.

	<a data-type="indexterm" data-primary="modules" data-secondary="naming of">&nbsp;</a></p>

      <p>We can now rewrite <code>freq.ml</code> to
      use <code>Counter</code>. 

      <div class="highlight"><pre><code class="language-ocaml">open Core_kernel

let build_counts () =
  In_channel.fold_lines In_channel.stdin ~init:[] ~f:Counter.touch

let () =
  build_counts ()
  |&gt; List.sort ~cmp:(fun (_,x) (_,y) -&gt; Int.descending x y)
  |&gt; (fun l -&gt; List.take l 10)
  |&gt; List.iter ~f:(fun (line,count) -&gt; printf "%3d: %s\n" count line)</code></pre></div>

      <p>The resulting code can still
      be built with <span class="command"><em>jbuilder</em></span>,
      which will discover dependencies and realize
      that <code>counter.ml</code> needs to be compiled.</p>
      </p>

      <div class="highlight"><pre><code class="language-ocaml">$ jbuilder build freq.bc
    ocamldep freq.depends.ocamldep-output
      ocamlc counter.{cmi,cmo,cmt}
      ocamlc freq.{cmi,cmo,cmt}
      ocamlc freq.bc
</code></pre></div>
      </section>

    <section id="signatures-and-abstract-types" data-type="sect1">
      <h1>Signatures and Abstract Types</h1>

      <p>While we've pushed some of the logic to the
      <code>Counter</code> module, the code in <code>freq.ml</code>
      can still depend on the details of the implementation of
      <code>Counter</code>. Indeed, if you look at the definition
      of <code>build_counts</code>, you'll see that it depends on
      the fact that the empty set of frequency counts is
      represented as an empty list. We'd like to prevent this kind
      of dependency, so we can change the implementation of
      <code>Counter</code> without needing to change client code
      like that in <code>freq.ml</code>.

      <a data-type="indexterm" data-primary="abstract types">&nbsp;</a>
      <a data-type="indexterm" data-primary="modules" data-secondary="module type">&nbsp;</a>
      <a data-type="indexterm" data-primary="signatures" data-secondary="abstract types">&nbsp;</a>
      <a data-type="indexterm" data-primary="interfaces" data-secondary="hiding implementation details with">&nbsp;</a>
      <a data-type="indexterm" data-primary="modules" data-secondary="hiding implementation details">&nbsp;</a></p>

      <p>The implementation details of a module can be hidden by
      attaching an <em>interface</em>. (Note that in the context of
      OCaml, the terms <em>interface</em>, <em>signature</em>, and
      <em>module type</em> are all used interchangeably.) A module
      defined by a file <code>filename.ml</code> can be constrained
      by a signature placed in a file called
      <code>filename.mli</code>.

      <a data-type="indexterm" data-primary="interfaces" data-secondary="synonyms for">&nbsp;</a></p>

      <p>For <code>counter.mli</code>, we'll start by writing down
      an interface that describes what's currently available in
      <code>counter.ml</code>, without hiding anything.
      <code>val</code> declarations are used to specify values in a
      signature. The syntax of a <code>val</code> declaration is as
      follows:</p>
      <div class="highlight"><pre><code class="language-ocaml">val &lt;identifier&gt; : &lt;type&gt;
</code></pre></div>

      <p>Using this syntax, we can write the signature
      of <code>counter.ml</code> as follows. </p> 

      <div class="highlight"><pre><code class="language-ocaml">open Core_kernel

(** Bump the frequency count for the given string. *)
val touch : (string * int) list -&gt; string -&gt; (string * int) list</code></pre></div>

      <p>Note that <span class="command"><em>jbuilder</em></span>
      will detect the presence of the <code>mli</code> file
      automatically and include it in the build.</p>

      
      

      
      
      
      

      

      
      

      
      
      
      
      
      
      
      

      <p>To hide the fact that frequency counts are represented as
      association lists, we'll need to make the type of frequency
      counts <em>abstract</em>. A type is abstract if its name is
      exposed in the interface, but its definition is not. Here's
      an abstract interface for <code>Counter</code>:</p>

      <div class="highlight"><pre><code class="language-ocaml">open Core_kernel

(** A collection of string frequency counts *)
type t

(** The empty set of frequency counts  *)
val empty : t

(** Bump the frequency count for the given string. *)
val touch : t -&gt; string -&gt; t

(** Converts the set of frequency counts to an association list.  A string shows
    up at most once, and the counts are &gt;= 1. *)
val to_list : t -&gt; (string * int) list</code></pre></div>

      <p>Note that we needed to add <code>empty</code> and
      <code>to_list</code> to <code>Counter</code>, since otherwise
      there would be no way to create a <code>Counter.t</code> or
      get data out of one.</p>

      <p>We also used this opportunity to document the
      module. The <code>mli</code> file is the place where you specify
      your module's interface, and as such is a natural place to put
      documentation. We started our comments with a double asterisk to
      cause them to be picked up by
      the <span class="command"><em>odoc</em></span> tool when
      generating API documentation. We'll
      discuss <span class="command"><em>odoc</em></span> more
      in <a href="22-compiler-frontend.html#the-compiler-frontend-parsing-and-type-checking" data-type="xref">Chapter 22, The Compiler Frontend Parsing And Type
      Checking</a>.</p>

      <p>Here's a rewrite of <code>counter.ml</code> to match the
      new <code>counter.mli</code>:</p>

      <div class="highlight"><pre><code class="language-ocaml">open Core_kernel

type t = (string * int) list

let empty = []

let to_list x = x

let touch counts line =
  let count = 
    match List.Assoc.find ~equal:String.equal counts line with
    | None -&gt; 0
    | Some x -&gt; x
  in
  List.Assoc.add ~equal:String.equal counts line (count + 1)</code></pre></div>

      <p>If we now try to compile <code>freq.ml</code>, we'll get
      the following error:</p>

      <div class="highlight"><pre><code class="language-ocaml">$ jbuilder build freq.bc
    ocamldep freq.depends.ocamldep-output
    ocamldep freq.dependsi.ocamldep-output
      ocamlc counter.{cmi,cmti}
      ocamlc freq.{cmi,cmo,cmt} (exit 2)
(cd _build/default &amp;&amp; /Users/avsm/.opam/4.06.0/bin/ocamlc.opt -w -40 -g -bin-annot -I /Users/avsm/.opam/4.06.0/lib/base -I /Users/avsm/.opam/4.06.0/lib/base/caml -I /Users/avsm/.opam/4.06.0/lib/base/md5 -I /Users/avsm/.opam/4.06.0/lib/base/shadow_stdlib -I /Users/avsm/.opam/4.06.0/lib/bin_prot -I /Users/avsm/.opam/4.06.0/lib/bin_prot/shape -I /Users/avsm/.opam/4.06.0/lib/core_kernel -I /Users/avsm/.opam/4.06.0/lib/core_kernel/base_for_tests -I /Users/avsm/.opam/4.06.0/lib/fieldslib -I /Users/avsm/.opam/4.06.0/lib/jane-street-headers -I /Users/avsm/.opam/4.06.0/lib/ocaml -I /Users/avsm/.opam/4.06.0/lib/ppx_assert/runtime-lib -I /Users/avsm/.opam/4.06.0/lib/ppx_bench/runtime-lib -I /Users/avsm/.opam/4.06.0/lib/ppx_compare/runtime-lib -I /Users/avsm/.opam/4.06.0/lib/ppx_expect/collector -I /Users/avsm/.opam/4.06.0/lib/ppx_expect/common -I /Users/avsm/.opam/4.06.0/lib/ppx_expect/config -I /Users/avsm/.opam/4.06.0/lib/ppx_hash/runtime-lib -I /Users/avsm/.opam/4.06.0/lib/ppx_inline_test/config -I /Users/avsm/.opam/4.06.0/lib/ppx_inline_test/runtime-lib -I /Users/avsm/.opam/4.06.0/lib/sexplib -I /Users/avsm/.opam/4.06.0/lib/sexplib/0 -I /Users/avsm/.opam/4.06.0/lib/stdio -I /Users/avsm/.opam/4.06.0/lib/typerep -I /Users/avsm/.opam/4.06.0/lib/variantslib -no-alias-deps -I . -o freq.cmo -c -impl freq.ml)
^[[1mFile "^[[1mfreq.ml", line 4, characters 53-66^[[0m^[[0m:
^[[1;31mError^[[0m: This expression has type Counter.t -&gt; string -&gt; Counter.t
       but an expression was expected of type 'a list -&gt; string -&gt; 'a list
       Type Counter.t is not compatible with type 'a list 
</code></pre></div>

      <p>This is because <code>freq.ml</code> depends on the fact that
      frequency counts are represented as association lists, a fact
      that we've just hidden. We just need to
      fix <code>build_counts</code> to use <code>Counter.empty</code>
      instead of <code>[]</code> and to
      use <code>Counter.to_list</code> to convert the completed counts
      to an association list. The resulting implementation is shown
      below.</p>

      <div class="highlight"><pre><code class="language-ocaml">open Core_kernel

let build_counts () =
  In_channel.fold_lines In_channel.stdin ~init:Counter.empty ~f:Counter.touch

let () =
  build_counts ()
  |&gt; Counter.to_list
  |&gt; List.sort ~cmp:(fun (_,x) (_,y) -&gt; Int.descending x y)
  |&gt; (fun counts -&gt; List.take counts 10)
  |&gt; List.iter ~f:(fun (line,count) -&gt; printf "%3d: %s\n" count line)</code></pre></div>

      With this implementation, the build now succeeds!

      <div class="highlight"><pre><code class="language-ocaml">$ jbuilder build freq.bc
    ocamldep freq.depends.ocamldep-output
    ocamldep freq.dependsi.ocamldep-output
      ocamlc counter.{cmi,cmti}
      ocamlc counter.{cmo,cmt}
      ocamlc freq.{cmi,cmo,cmt}
      ocamlc freq.bc
</code></pre></div>

      <p>Now we can turn to optimizing the implementation
      of <code>Counter</code>. Here's an alternate and far more
      efficient implementation, based on the <code>Map</code> data
      structure in <code>Core_kernel</code>.</p> 
      
      <div class="highlight"><pre><code class="language-ocaml">open Core_kernel

type t = int String.Map.t

let empty = String.Map.empty

let to_list t = Map.to_alist t

let touch t s =
  let count =
    match Map.find t s with
    | None -&gt; 0
    | Some x -&gt; x
  in
  Map.add t ~key:s ~data:(count + 1)</code></pre></div>

      <p>Note that in the preceding example we use
      <code>String.Map</code> in some places and simply
      <code>Map</code> in others. This has to do with the fact that
      for some operations, like creating a <code>Map.t</code>, you
      need access to type-specialized information, and for others,
      like looking something up in <code>Map.t</code>, you don't.
      This is covered in more detail in <a href="13-maps-and-hashtables.html#maps-and-hash-tables" data-type="xref">Chapter 13, Maps And Hash Tables</a>.</p>
    </section>

    <section id="concrete-types-in-signatures" data-type="sect1">
      <h1>Concrete Types in Signatures</h1>

      <p>In our frequency-count example, the module
      <code>Counter</code> had an abstract type
      <code>Counter.t</code> for representing a collection of
      frequency counts. Sometimes, you'll want to make a type in
      your interface <em>concrete</em>, by including the type
      definition in the interface.

      <a data-type="indexterm" data-primary="concrete types">&nbsp;</a>
      <a data-type="indexterm" data-primary="signatures" data-secondary="concrete types">&nbsp;</a></p>

      <p>For example, imagine we wanted to add a function
      to <code>Counter</code> for returning the line with the median
      frequency count. If the number of lines is even, then there is
      no precise median, and the function would return the lines
      before and after the median instead. We'll use a custom type to
      represent the fact that there are two possible return
      values. Here's a possible implementation:</p>

      <div class="highlight"><pre><code class="language-ocaml">type median = | Median of string
              | Before_and_after of string * string

let median t =
  let sorted_strings = 
    List.sort (Map.to_alist t)
      ~cmp:(fun (_,x) (_,y) -&gt; Int.descending x y)
  in
  let len = List.length sorted_strings in
  if len = 0 then failwith "median: empty frequency count";
  let nth n = fst (List.nth_exn sorted_strings n) in
  if len mod 2 = 1
  then Median (nth (len/2))
  else Before_and_after (nth (len/2 - 1), nth (len/2));;</code></pre></div>

      <p>In the above, we use <code>failwith</code> to throw an
      exception for the case of the empty list. We'll discuss
      exceptions more
      in <a href="07-error-handling.html#error-handling" data-type="xref">Chapter 7, Error Handling</a>. Note also that the
      function <code>fst</code> simply returns the first element of
      any two-tuple.</p>

      <p>Now, to expose this usefully in the interface, we need to
      expose both the function and the type <code>median</code> with
      its definition. Note that values (of which functions are an
      example) and types have distinct namespaces, so there's no name
      clash here. Adding the following two lines
      to <code>counter.mli</code> does the trick.</p>

      <div class="highlight"><pre><code class="language-ocaml">(** Represents the median computed from a set of strings.  In the case where
    there is an even number of choices, the one before and after the median is
    returned.  *)
type median = | Median of string
              | Before_and_after of string * string

val median : t -&gt; median</code></pre></div>

      <p>The decision of whether a given type should be abstract or
      concrete is an important one. Abstract types give you more
      control over how values are created and accessed, and make it
      easier to enforce invariants beyond what is enforced by the
      type itself; concrete types let you expose more detail and
      structure to client code in a lightweight way. The right
      choice depends very much on the context.</p>
    </section>

    <section id="nested-modules" data-type="sect1">
      <h1>Nested Modules</h1>

      <p>Up until now, we've only considered modules that
      correspond to files, like <code>counter.ml</code>. But
      modules (and module signatures) can be nested inside other
      modules. As a simple example, consider a program that needs
      to deal with multiple identifiers like usernames and
      hostnames. If you just represent these as strings, then it
      becomes easy to confuse one with the
      other.

	<a data-type="indexterm" data-primary="identifiers" data-secondary="dealing with multiple">&nbsp;</a>
	<a data-type="indexterm" data-primary="nested modules">&nbsp;</a>
	<a data-type="indexterm" data-primary="modules" data-secondary="nested modules">&nbsp;</a></p>

      <p>A better approach is to mint new abstract types for each
      identifier, where those types are under the covers just
      implemented as strings. That way, the type system will
      prevent you from confusing a username with a hostname, and if
      you do need to convert, you can do so using explicit
      conversions to and from the string type.</p>

      <p>Here's how you might create such an abstract type, within
      a submodule:

	<a data-type="indexterm" data-primary="abstract types">&nbsp;</a></p>

      <div class="highlight"><pre><code class="language-ocaml">open Core

module Username : sig
  type t
  val of_string : string -&gt; t
  val to_string : t -&gt; string
end = struct
  type t = string
  let of_string x = x
  let to_string x = x
end</code></pre></div>

      <p>Note that the <code>to_string</code> and
      <code>of_string</code> functions above are implemented simply
      as the identity function, which means they have no runtime
      effect. They are there purely as part of the discipline that
      they enforce on the code through the type system.</p>

      <p>The basic structure of a module declaration like this
      is:</p>

      <div class="highlight"><pre><code class="language-ocaml">module &lt;name&gt; : &lt;signature&gt; = &lt;implementation&gt;
</code></pre></div>

      <p>We could have written this slightly differently, by giving
      the signature its own top-level <code>module type</code>
      declaration, making it possible to create multiple distinct
      types with the same underlying implementation in a
      lightweight way:</p>

      <div class="highlight"><pre><code class="language-ocaml">open Core_kernel

module type ID = sig
  type t
  val of_string : string -&gt; t
  val to_string : t -&gt; string
end

module String_id = struct
  type t = string
  let of_string x = x
  let to_string x = x
end

module Username : ID = String_id
module Hostname : ID = String_id

type session_info = { user: Username.t;
                      host: Hostname.t;
                      when_started: Time.t;
                    }

let sessions_have_same_user s1 s2 =
  s1.user = s2.host</code></pre></div>

      <p>The preceding code has a bug: it compares the username in
      one session to the host in the other session, when it should
      be comparing the usernames in both cases. Because of how we
      defined our types, however, the compiler will flag this bug
      for us.</p>
      <div class="highlight"><pre><code class="language-ocaml">$ jbuilder build session_info.exe
    ocamldep session_info.depends.ocamldep-output
      ocamlc session_info.{cmi,cmo,cmt} (exit 2)
(cd _build/default &amp;&amp; /Users/avsm/.opam/4.06.0/bin/ocamlc.opt -w -40 -g -bin-annot -I /Users/avsm/.opam/4.06.0/lib/base -I /Users/avsm/.opam/4.06.0/lib/base/caml -I /Users/avsm/.opam/4.06.0/lib/base/md5 -I /Users/avsm/.opam/4.06.0/lib/base/shadow_stdlib -I /Users/avsm/.opam/4.06.0/lib/bin_prot -I /Users/avsm/.opam/4.06.0/lib/bin_prot/shape -I /Users/avsm/.opam/4.06.0/lib/core_kernel -I /Users/avsm/.opam/4.06.0/lib/core_kernel/base_for_tests -I /Users/avsm/.opam/4.06.0/lib/fieldslib -I /Users/avsm/.opam/4.06.0/lib/jane-street-headers -I /Users/avsm/.opam/4.06.0/lib/ocaml -I /Users/avsm/.opam/4.06.0/lib/ppx_assert/runtime-lib -I /Users/avsm/.opam/4.06.0/lib/ppx_bench/runtime-lib -I /Users/avsm/.opam/4.06.0/lib/ppx_compare/runtime-lib -I /Users/avsm/.opam/4.06.0/lib/ppx_expect/collector -I /Users/avsm/.opam/4.06.0/lib/ppx_expect/common -I /Users/avsm/.opam/4.06.0/lib/ppx_expect/config -I /Users/avsm/.opam/4.06.0/lib/ppx_hash/runtime-lib -I /Users/avsm/.opam/4.06.0/lib/ppx_inline_test/config -I /Users/avsm/.opam/4.06.0/lib/ppx_inline_test/runtime-lib -I /Users/avsm/.opam/4.06.0/lib/sexplib -I /Users/avsm/.opam/4.06.0/lib/sexplib/0 -I /Users/avsm/.opam/4.06.0/lib/stdio -I /Users/avsm/.opam/4.06.0/lib/typerep -I /Users/avsm/.opam/4.06.0/lib/variantslib -no-alias-deps -I . -o session_info.cmo -c -impl session_info.ml)
^[[1mFile "^[[1msession_info.ml", line 24, characters 12-19^[[0m^[[0m:
^[[1;31mError^[[0m: This expression has type Hostname.t
       but an expression was expected of type Username.t
</code></pre></div>

      <p>This is a trivial example, but confusing different kinds
      of identifiers is a very real source of bugs, and the
      approach of minting abstract types for different classes of
      identifiers is an effective way of avoiding such issues.</p>
    </section>

    <section id="opening-modules" data-type="sect1">
      <h1>Opening Modules</h1>

      <p>Most of the time, you refer to values and types within a
      module by using the module name as an explicit qualifier. For
      example, you write <code>List.map</code> to refer to the
      <code>map</code> function in the <code>List</code> module.
      Sometimes, though, you want to be able to refer to the
      contents of a module without this explicit qualification.
      That's what the <code>open</code> statement is
      for.

      <a data-type="indexterm" data-primary="identifiers" data-secondary="open modules and">&nbsp;</a>
      <a data-type="indexterm" data-primary="modules" data-secondary="opening">&nbsp;</a></p>

      <p>We've encountered <code>open</code> already, specifically
      where we've written <code>open Core_kernel</code> to get
      access to the standard definitions in the
      <code>Core_kernel</code> library. In general, opening a
      module adds the contents of that module to the environment
      that the compiler looks at to find the definition of various
      identifiers. Here's an example:</p>

      <div class="highlight"><pre><code class="language-ocaml"># open Core_kernel;;</code></pre><pre><code class="language-ocaml"># module M = struct let foo = 3 end;;</code></pre><pre class="ge"><code class="language-ocaml">module M : sig val foo : int end</code></pre><pre><code class="language-ocaml"># foo;;</code></pre><pre class="ge"><code class="language-ocaml">
Characters 0-3:
Error: Unbound value foo
</code></pre><pre><code class="language-ocaml"># open M;;</code></pre><pre><code class="language-ocaml"># foo;;</code></pre><pre class="ge"><code class="language-ocaml">- : int = 3</code></pre></div>

      <p><code>open</code> is essential when you want to modify
      your environment for a standard library like
      <code>Core_kernel</code>, but it's generally good style to
      keep the opening of modules to a minimum. Opening a module is
      basically a trade-off between terseness and explicitnessâ€”the
      more modules you open, the fewer module qualifications you
      need, and the harder it is to look at an identifier and
      figure out where it comes from.</p>

      <p>Here's some general advice on how to deal with
      <code>open</code>s:

      <a data-type="indexterm" data-primary="local opens">&nbsp;</a></p>

      <ul>
        <li>
          <p>Opening modules at the toplevel of a module should be
          done quite sparingly, and generally only with modules
          that have been specifically designed to be opened, like
          <code>Core_kernel</code> or
          <code>Option.Monad_infix</code>.</p>
        </li>

        <li>
          <p>If you do need to do an open, it's better to do a
          <em>local open</em>. There are two syntaxes for local
          opens. For example, you can write:</p>
        </li>
      </ul>

      <div class="highlight"><pre><code class="language-ocaml"># let average x y =
    let open Int64 in
    x + y / of_int 2;;</code></pre><pre class="ge"><code class="language-ocaml">val average : int64 -&gt; int64 -&gt; int64 = &lt;fun&gt;</code></pre></div>

      <p>Here, <code>of_int</code> and the infix operators are the
      ones from the <code>Int64</code> module.</p>

      <p>There's another, even more lightweight syntax for local
      <code>open</code>s, which is particularly useful for small
      expressions:</p>

      <div class="highlight"><pre><code class="language-ocaml"># let average x y =
    Int64.(x + y / of_int 2);;</code></pre><pre class="ge"><code class="language-ocaml">val average : int64 -&gt; int64 -&gt; int64 = &lt;fun&gt;</code></pre></div>

      <ul>
        <li>
          <p>An alternative to local <code>open</code>s that makes
          your code terser without giving up on explicitness is to
          locally rebind the name of a module. So, when using the
          <code>Counter.median</code> type, instead of writing:</p>
        </li>

        <li style="list-style: none; display: inline">

          <div class="highlight"><pre><code class="language-ocaml">let print_median m =
  match m with
  | Counter.Median string -&gt; printf "True median:\n   %s\n" string
  | Counter.Before_and_after (before, after) -&gt;
    printf "Before and after median:\n   %s\n   %s\n" before after</code></pre></div>

          <p>you could write:</p>

          <div class="highlight"><pre><code class="language-ocaml">let print_median m =
  let module C = Counter in
  match m with
  | C.Median string -&gt; printf "True median:\n   %s\n" string
  | C.Before_and_after (before, after) -&gt;
    printf "Before and after median:\n   %s\n   %s\n" before after</code></pre></div>

          <p>Because the module name <code>C</code> only exists for
          a short scope, it's easy to read and remember what
          <code>C</code> stands for. Rebinding modules to very
          short names at the top level of your module is usually a
          mistake.</p>
        </li>
      </ul>
    </section>

    <section id="including-modules" data-type="sect1">
      <h1>Including Modules</h1>

      <p>While opening a module affects the environment used to
      search for identifiers, <em>including</em> a module is a way
      of actually adding new identifiers to a module proper.
      Consider the following simple module for representing a range
      of integer
      values:

	<a data-type="indexterm" data-primary="modules" data-secondary="including">&nbsp;</a>
	<a data-type="indexterm" data-primary="identifiers" data-secondary="adding to modules">&nbsp;</a></p>

      <div class="highlight"><pre><code class="language-ocaml"># module Interval = struct
    type t = | Interval of int * int
             | Empty
  
    let create low high =
      if high &lt; low then Empty else Interval (low,high)
  end;;</code></pre><pre class="ge"><code class="language-ocaml">
module Interval :
  sig type t = Interval of int * int | Empty val create : int -&gt; int -&gt; t end
</code></pre></div>

      <p>We can use the <code>include</code> directive to create a
      new, extended version of the <code>Interval</code>
      module:</p>

      <div class="highlight"><pre><code class="language-ocaml"># module Extended_interval = struct
    include Interval
  
    let contains t x =
      match t with
      | Empty -&gt; false
      | Interval (low,high) -&gt; x &gt;= low &amp;&amp; x &lt;= high
  end;;</code></pre><pre class="ge"><code class="language-ocaml">
module Extended_interval :
  sig
    type t = Interval.t = Interval of int * int | Empty
    val create : int -&gt; int -&gt; t
    val contains : t -&gt; int -&gt; bool
  end
</code></pre><pre><code class="language-ocaml"># Extended_interval.contains (Extended_interval.create 3 10) 4;;</code></pre><pre class="ge"><code class="language-ocaml">- : bool = true</code></pre></div>

      <p>The difference between <code>include</code> and
      <code>open</code> is that we've done more than change how
      identifiers are searched for: we've changed what's in the
      module. If we'd used <code>open</code>, we'd have gotten a
      quite different result:</p>

      <div class="highlight"><pre><code class="language-ocaml"># module Extended_interval = struct
    open Interval
  
    let contains t x =
      match t with
      | Empty -&gt; false
      | Interval (low,high) -&gt; x &gt;= low &amp;&amp; x &lt;= high
  end;;</code></pre><pre class="ge"><code class="language-ocaml">
module Extended_interval :
  sig val contains : Extended_interval.t -&gt; int -&gt; bool end
</code></pre><pre><code class="language-ocaml"># Extended_interval.contains (Extended_interval.create 3 10) 4;;</code></pre><pre class="ge"><code class="language-ocaml">
Characters 28-52:
Error: Unbound value Extended_interval.create
</code></pre></div>

      <p>To consider a more realistic example, imagine you wanted
      to build an extended version of the <code>List</code> module,
      where you've added some functionality not present in the
      module as distributed in <code>Core_kernel</code>.
      <code>include</code> allows us to do just that:</p>

      <div class="highlight"><pre><code class="language-ocaml">open Core_kernel

(* The new function we're going to add *)
let rec intersperse list el =
  match list with
  | [] | [ _ ]   -&gt; list
  | x :: y :: tl -&gt; x :: el :: intersperse (y::tl) el

(* The remainder of the list module *)
include List</code></pre></div>

      <p>Now, how do we write an interface for this new module? It
      turns out that <code>include</code> works on signatures as
      well, so we can pull essentially the same trick to write our
      <code>mli</code>. The only issues is that we need to get our
      hands on the signature for the <code>List</code> module. This
      can be done using <code>module type of</code>, which computes
      a signature from a module:</p>

      <div class="highlight"><pre><code class="language-ocaml">open Core_kernel

(* Include the interface of the list module from Core *)
include (module type of List)

(* Signature of function we're adding *)
val intersperse : 'a list -&gt; 'a -&gt; 'a list</code></pre></div>

      <p>Note that the order of declarations in the
      <code>mli</code> does not need to match the order of
      declarations in the <code>ml</code>. The order of
      declarations in the <code>ml</code> mostly matters insofar as
      it affects which values are shadowed. If we wanted to replace
      a function in <code>List</code> with a new function of the
      same name, the declaration of that function in the
      <code>ml</code> would have to come after the <code>include
      List</code> declaration.</p>

      <p>We can now use <code>Ext_list</code> as a replacement for
      <code>List</code>. If we want to use <code>Ext_list</code> in
      preference to <code>List</code> in our project, we can create
      a file of common definitions:</p>

      <div class="highlight"><pre><code class="language-ocaml">module List = Ext_list</code></pre></div>

      <p>And if we then put <code>open Common</code> after
      <code>open Core_kernel</code> at the top of each file in
      our project, then references to <code>List</code> will
      automatically go to <code>Ext_list</code> instead.</p>
    </section>

    <section id="common-errors-with-modules" data-type="sect1">
      <h1>Common Errors with Modules</h1>

      <p>When OCaml compiles a program with an <code>ml</code> and
      an <code>mli</code>, it will complain if it detects a
      mismatch between the two. Here are some of the common errors
      you'll run into.</p>

      <section id="type-mismatches" data-type="sect2">
        <h2>Type Mismatches</h2>

        <p>The simplest kind of error is where the type specified
        in the signature does not match the type in the
        implementation of the module. As an example, if we replace
        the <code>val</code> declaration in
        <code>counter.mli</code> by swapping the types of the first
        two arguments:

	<a data-type="indexterm" data-primary="errors" data-secondary="module type mismatches">&nbsp;</a>
	<a data-type="indexterm" data-primary="type mismatches">&nbsp;</a>
	<a data-type="indexterm" data-primary="modules" data-secondary="type mismatches in">&nbsp;</a></p>

        <div class="highlight"><pre><code class="language-ocaml">(** Bump the frequency count for the given string. *)
val touch : t -&gt; string -&gt; t
</code></pre></div>

        <p>and we try to compile, we'll get the following error.</p>

        <div class="highlight"><pre><code class="language-ocaml">$ jbuilder build freq.bc
Don't know how to build freq.bc
</code></pre></div>

        </section>

      <section id="missing-definitions" data-type="sect2">
        <h2>Missing Definitions</h2>

        <p>We might decide that we want a new function in
        <code>Counter</code> for pulling out the frequency count of
        a given string. We can update the <code>mli</code> by
        adding the following line:

	<a data-type="indexterm" data-primary="errors" data-secondary="missing module definitions">&nbsp;</a>
	<a data-type="indexterm" data-primary="modules" data-secondary="missing definitions in">&nbsp;</a></p>

        <div class="highlight"><pre><code class="language-ocaml">val count : t -&gt; string -&gt; int</code></pre></div>

        <p>Now if we try to compile without actually adding the
        implementation, we'll get this error.</p>

        <div class="highlight"><pre><code class="language-ocaml">$ jbuilder build counter.bc
Don't know how to build counter.bc
</code></pre></div>

        <p>A missing type definition will lead to a similar
        error.</p>
      </section>

      <section id="type-definition-mismatches" data-type="sect2">
        <h2>Type Definition Mismatches</h2>

        <p>Type definitions that show up in an <code>mli</code>
        need to match up with corresponding definitions in the
        <code>ml</code>. Consider again the example of the type
        <code>median</code>. The order of the declaration of
        variants matters to the OCaml compiler, so the definition
        of <code>median</code> in the implementation listing those
        options in a different order:
	<a data-type="indexterm" data-primary="type definition mismatches">&nbsp;</a>
	<a data-type="indexterm" data-primary="errors" data-secondary="module type definition mismatches">&nbsp;</a>
	<a data-type="indexterm" data-primary="modules" data-secondary="type definition mismatches">&nbsp;</a></p>

        <div class="highlight"><pre><code class="language-ocaml">(** Represents the median computed from a set of strings.  In the case where
    there is an even number of choices, the one before and after the median is
    returned.  *)
type median = | Before_and_after of string * string
              | Median of string

val median : t -&gt; median</code></pre></div>

        <p>will lead to a compilation error.</p>
        <div class="highlight"><pre><code class="language-ocaml">$ jbuilder build freq.bc
    ocamldep freq.depends.ocamldep-output
    ocamldep freq.dependsi.ocamldep-output
      ocamlc counter.{cmi,cmti}
      ocamlc freq.{cmi,cmo,cmt}
      ocamlc counter.{cmo,cmt} (exit 2)
(cd _build/default &amp;&amp; /Users/avsm/.opam/4.06.0/bin/ocamlc.opt -w -40 -g -bin-annot -I /Users/avsm/.opam/4.06.0/lib/base -I /Users/avsm/.opam/4.06.0/lib/base/caml -I /Users/avsm/.opam/4.06.0/lib/base/md5 -I /Users/avsm/.opam/4.06.0/lib/base/shadow_stdlib -I /Users/avsm/.opam/4.06.0/lib/bin_prot -I /Users/avsm/.opam/4.06.0/lib/bin_prot/shape -I /Users/avsm/.opam/4.06.0/lib/core_kernel -I /Users/avsm/.opam/4.06.0/lib/core_kernel/base_for_tests -I /Users/avsm/.opam/4.06.0/lib/fieldslib -I /Users/avsm/.opam/4.06.0/lib/jane-street-headers -I /Users/avsm/.opam/4.06.0/lib/ocaml -I /Users/avsm/.opam/4.06.0/lib/ppx_assert/runtime-lib -I /Users/avsm/.opam/4.06.0/lib/ppx_bench/runtime-lib -I /Users/avsm/.opam/4.06.0/lib/ppx_compare/runtime-lib -I /Users/avsm/.opam/4.06.0/lib/ppx_expect/collector -I /Users/avsm/.opam/4.06.0/lib/ppx_expect/common -I /Users/avsm/.opam/4.06.0/lib/ppx_expect/config -I /Users/avsm/.opam/4.06.0/lib/ppx_hash/runtime-lib -I /Users/avsm/.opam/4.06.0/lib/ppx_inline_test/config -I /Users/avsm/.opam/4.06.0/lib/ppx_inline_test/runtime-lib -I /Users/avsm/.opam/4.06.0/lib/sexplib -I /Users/avsm/.opam/4.06.0/lib/sexplib/0 -I /Users/avsm/.opam/4.06.0/lib/stdio -I /Users/avsm/.opam/4.06.0/lib/typerep -I /Users/avsm/.opam/4.06.0/lib/variantslib -no-alias-deps -I . -o counter.cmo -c -impl counter.ml)
^[[1mFile "^[[1mcounter.ml", line 15, characters 2-9^[[0m^[[0m:
^[[1;35mWarning^[[0m 3: deprecated: Core_kernel.Map.add
[since 2017-11] Use [set] instead
^[[1mFile "^[[1mcounter.ml", line 1^[[0m^[[0m:
^[[1;31mError^[[0m: The implementation counter.ml
       does not match the interface counter.cmi:
       Type declarations do not match:
         type median = Median of string | Before_and_after of string * string
       is not included in
         type median = Before_and_after of string * string | Median of string
       File "^[[1mcounter.mli", line 20, characters 0-84^[[0m: Expected declaration
       File "^[[1mcounter.ml", line 18, characters 0-84^[[0m: Actual declaration
       Fields number 1 have different names, Median and Before_and_after.
</code></pre></div>

        <p>Order is similarly important to other type declarations,
        including the order in which record fields are declared and
        the order of arguments (including labeled and optional
        arguments) to a function.</p>
      </section>

      <section id="cyclic-dependencies" data-type="sect2">
        <h2>Cyclic Dependencies</h2>

        <p>In most cases, OCaml doesn't allow cyclic dependencies,
        i.e., a collection of definitions that all refer to one
        another. If you want to create such definitions, you typically
        have to mark them specially. For example, when defining a set
        of mutually recursive values (like the definition
        of <code>is_even</code> and <code>is_odd</code>
        in <a href="02-variables-and-functions.html#recursive-functions" data-type="xref">Chapter 2, Recursive Functions</a>), you need to define
        them using <code>let rec</code> rather than
        ordinary <code>let</code>.

	<a data-type="indexterm" data-primary="dependencies, cyclic">&nbsp;</a>
	<a data-type="indexterm" data-primary="cyclic dependencies">&nbsp;</a>
	<a data-type="indexterm" data-primary="errors" data-secondary="cyclic dependencies">&nbsp;</a>
	<a data-type="indexterm" data-primary="modules" data-secondary="cyclic dependencies">&nbsp;</a></p>

        <p>The same is true at the module level. By default, cyclic
        dependencies between modules are not allowed, and cyclic
        dependencies among files are never allowed. Recursive
        modules are possible but are a rare case, and we won't
        discuss them further here.</p>

        <p>The simplest example of a forbidden circular reference is a
        module referring to its own module name. So, if we tried to
        add a reference to <code>Counter</code> from
        within <code>counter.ml</code>.</p>

        <div class="highlight"><pre><code class="language-ocaml">let singleton l = Counter.touch Counter.empty</code></pre></div>

        <p>we'll see this error when we try to build:</p>
        <div class="highlight"><pre><code class="language-ocaml">$ jbuilder build freq.bc
Don't know how to build freq.bc
</code></pre></div>

        <p>The problem manifests in a different way if we create
        cyclic references between files. We could create such a
        situation by adding a reference to <code>Freq</code> from
        <code>counter.ml</code>, e.g., by adding the following
        line.</p>

        <div class="highlight"><pre><code class="language-ocaml">let _build_counts = Freq.build_counts</code></pre></div>

        <p>In this case, 
	  <span class="command"><em>jbuilder</em></span> will
        notice the error and complain explicitly about the cycle:</p>
        <div class="highlight"><pre><code class="language-ocaml">$ jbuilder build freq.bc
Don't know how to build freq.bc
</code></pre></div>
      </section>
    </section>

    <section data-type="sect1">
      <h1>Designing with Modules</h1>

      <p>The module system is a key part of how an OCaml program is
      structured. As such, we'll close this chapter with some
      advice on how to think about designing that structure
      effectively.</p>

      <section data-type="sect2">
        <h2>Expose Concrete Types Rarely</h2>

        <p>When designing an <code>mli</code>, one choice that you
        need to make is whether to expose the concrete definition
        of your types or leave them abstract. Most of the time,
        abstraction is the right choice, for two reasons: it
        enhances the flexibility of your design, and it makes it
        possible to enforce invariants on the use of your
        module.</p>

        <p>Abstraction enhances flexibility by restricting how
        users can interact with your types, thus reducing the ways
        in which users can depend on the details of your
        implementation. If you expose types explicitly, then users
        can depend on any and every detail of the types you choose.
        If they're abstract, then only the specific operations you
        want to expose are available. This means that you can
        freely change the implementation without affecting clients,
        as long as you preserve the semantics of those
        operations.</p>

        <p>In a similar way, abstraction allows you to enforce
        invariants on your types. If your types are exposed, then
        users of the module can create new instances of that type
        (or if mutable, modify existing instances) in any way
        allowed by the underlying type. That may violate a desired
        invariant <em>i.e.</em>, a property about your type that is
        always supposed to be true. Abstract types allow you to
        protect invariants by making sure that you only expose
        functions that preserves your invariants.</p>

        <p>Despite these benefits, there is a trade-off here. In
        particular, exposing types concretely makes it possible to
        use pattern-matching with those types, which as we saw in
        <span class="keep-together"><a href="03-lists-and-patterns.html#lists-and-patterns" data-type="xref">Chapter 3, Lists And Patterns</a></span> is a powerful and
        important tool. You should generally only expose the
        concrete implementation of your types when there's
        significant value in the ability to pattern match, and when
        the invariants that you care about are already enforced by
        the data type itself.</p>
      </section>

      <section data-type="sect2">
        <h2>Design for the Call Site</h2>

        <p>When writing an interface, you should think not just
        about how easy it is to understand the interface for
        someone who reads your carefully documented
        <code>mli</code> file, but more importantly, you want the
        call to be as obvious as possible for someone who is
        reading it at the call site.</p>

        <p>The reason for this is that most of the time, people
        interacting with your API will be doing so by reading and
        modifying code that uses the API, not by reading the
        interface definition. By making your API as obvious as
        possible from that perspective, you simplify the lives of
        your users.</p>

        <p>There are many ways of improving readability at the call
        site. One example is labeled arguments (discussed in
        <a href="02-variables-and-functions.html#labeled-arguments" data-type="xref">Chapter 2, Labeled Arguments</a>), which act as
        documentation that is available at the call site.</p>

        <p>You can also improve readability simply by choosing good
        names for your functions, variant tags and record fields.
        Good names aren't always long, to be clear. If you wanted
        to write an anonymous function for doubling a number:
        <code>(fun x -&gt; x * 2)</code>, a short variable name
        like <code>x</code> is best. A good rule of thumb is that
        names that have a small scope should be short, whereas
        names that have a large scope, like the name of a function
        in an a module interface, should be longer and more
        explicit.</p>

        <p>There is of course a tradeoff here, in that making your
        APIs more explicit tends to make them more verbose as well.
        Another useful rule of thumb is that more rarely used names
        should be longer and more explicit, since the cost of
        concision and the benefit of explicitness become more
        important the more often a name is used.</p>
      </section>

      <section data-type="sect2">
        <h2>Create Uniform Interfaces</h2>

        <p>Designing the interface of a module is a task that
        should not be thought of in isolation. The interfaces that
        appear in your codebase should play together harmoniously.
        Part of achieving that is standardizing aspects of those
        interfaces.</p>

        <p><code>Core</code> and <code>Core_kernel</code> are
        libraries that work hard to create uniform interfaces. Here
        are some of the guidelines that they use.</p>

        <ul>
          <li>
            <p><em>A module for (almost) every type.</em> You
            should mint a module for almost every type in your
            program, and the primary type of a given module should
            be called <code>t</code>.</p>
          </li>

          <li>
            <p><em>Put <code>t</code> first</em>. If you have a
            module <code>M</code> whose primary type is
            <code>M.t</code>, the functions in <code>M</code> that
            take a value of <code>M.t</code> should take it as
            their first argument.</p>
          </li>

          <li>
            <p>Functions that routinely throw an exception should
            end in <code>_exn</code>. Otherwise, errors should be
            signaled by returning an <code>option</code> or an
            <code>Or_error.t</code> (both of which are discussed in
            <a href="07-error-handling.html#error-handling" data-type="xref">Chapter 7, Error Handling</a> ).</p>
          </li>
        </ul>

        <p>There are also standards in Core about what the type
        signature for specific functions should be. For example,
        the signature for <code>map</code> is always essentially
        the same, no matter what the underlying type it is applied
        to. This kind of function-by-function API uniformity is
        achieved through the use of <em>signature includes</em>,
        which allow for different modules to share components of
        their interface. This approach is described in <a href="09-functors.html#using-multiple-interfaces" data-type="xref">Chapter 9, Using Multiple Interfaces</a>.</p>

        <p>Core's standards may or may not fit your projects, but
        you can improve the usability of your codebase by finding
        some consistent set of standards to apply.</p>
      </section>

      <section data-type="sect2">
        <h2>Interfaces before implementations</h2>

        <p>OCaml's concise and flexible type language enables a
        type-oriented approach to software design. Such an approach
        involves thinking through and writing out the types you're
        going to use before embarking on the implementation
        itself.</p>

        <p>This is a good approach both when working in the core
        language, where you would write your type definitions
        before writing the logic of your computations, as well as
        at the module level, where you would write a first draft of
        your <code>mli</code> before working on the
        <code>ml</code>.</p>

        <p>Of course, the design process goes in both directions.
        You'll often find yourself going back and modifying your
        types in response to things you learn by working on the
        implementation. But types and signatures provide a
        lightweight tool for constructing a skeleton of your design
        in a way that helps clarify your goals and intent, before
        you spend a lot of time and effort fleshing it out.</p>
      </section>
    </section>
  </section>
</article></div><a class="next-chapter" href="05-records.html"><div class="content"><h1><small>Next: Chapter 05</small>Records</h1></div></a><footer><div class="content"><ul><li><a href="http://twitter.com/realworldocaml">@realworldocaml</a></li><li><a href="http://twitter.com/yminsky">@yminsky</a></li><li><a href="http://twitter.com/avsm">@avsm</a></li><li><a href="https://plus.google.com/111219778721183890368">+hickey</a></li><li><a href="https://github.com/realworldocaml">GitHub</a></li><li><a href="http://www.goodreads.com/book/show/16087552-real-world-ocaml">goodreads</a></li></ul><p>Copyright 2012-2014 Jason Hickey, Anil Madhavapeddy and Yaron Minsky.</p></div></footer><script src="js/jquery.min.js"></script><script src="js/min/app-min.js"></script><script src="js/discourse.js"></script></body></html>